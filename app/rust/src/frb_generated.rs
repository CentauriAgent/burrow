// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::state::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 66455663;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__state__BurrowState_auto_accessor_get_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BurrowState_auto_accessor_get_client",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.client.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__state__BurrowState_auto_accessor_get_keys_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BurrowState_auto_accessor_get_keys",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.keys.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__state__BurrowState_auto_accessor_get_mdk_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BurrowState_auto_accessor_get_mdk",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.mdk.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__state__BurrowState_auto_accessor_set_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BurrowState_auto_accessor_set_client",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
            >>::sse_decode(&mut deserializer);
            let api_client = <Client>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.client = api_client;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__state__BurrowState_auto_accessor_set_keys_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BurrowState_auto_accessor_set_keys",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
            >>::sse_decode(&mut deserializer);
            let api_keys = <Keys>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.keys = api_keys;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__state__BurrowState_auto_accessor_set_mdk_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BurrowState_auto_accessor_set_mdk",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
            >>::sse_decode(&mut deserializer);
            let api_mdk = <MDK<MdkMemoryStorage>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.mdk = api_mdk;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__call_signaling__accept_call_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "accept_call",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sdp_answer = <String>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_caller_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::accept_call(
                            api_sdp_answer,
                            api_call_id,
                            api_caller_pubkey_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__accept_welcome_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "accept_welcome",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_welcome_event_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::invite::accept_welcome(api_welcome_event_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__add_members_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_members",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_key_package_events_json = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::invite::add_members(
                            api_mls_group_id_hex,
                            api_key_package_events_json,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__relay__add_relay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "add_relay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::relay::add_relay(api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_signaling__build_group_call_signaling_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_group_call_signaling",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind_num = <u32>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_call_type = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::build_group_call_signaling(
                            api_kind_num,
                            api_content,
                            api_call_id,
                            api_call_type,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__media__build_imeta_tag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "build_imeta_tag",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_mime_type = <String>::sse_decode(&mut deserializer);
            let api_filename = <String>::sse_decode(&mut deserializer);
            let api_original_hash_hex = <String>::sse_decode(&mut deserializer);
            let api_nonce_hex = <String>::sse_decode(&mut deserializer);
            let api_dimensions = <Option<String>>::sse_decode(&mut deserializer);
            let api_blurhash = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::media::build_imeta_tag(
                        api_url,
                        api_mime_type,
                        api_filename,
                        api_original_hash_hex,
                        api_nonce_hex,
                        api_dimensions,
                        api_blurhash,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_quality__calculate_quality_score_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "calculate_quality_score",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_rtt_ms = <f64>::sse_decode(&mut deserializer);
            let api_jitter_ms = <f64>::sse_decode(&mut deserializer);
            let api_packet_loss_percent = <f64>::sse_decode(&mut deserializer);
            let api_bitrate_kbps = <f64>::sse_decode(&mut deserializer);
            let api_is_video = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::call_quality::calculate_quality_score(
                            api_rtt_ms,
                            api_jitter_ms,
                            api_packet_loss_percent,
                            api_bitrate_kbps,
                            api_is_video,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__relay__connect_relays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "connect_relays",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::relay::connect_relays().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__account__create_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::account::create_account().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__create_group_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_group",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            let api_description = <String>::sse_decode(&mut deserializer);
            let api_admin_pubkeys_hex = <Vec<String>>::sse_decode(&mut deserializer);
            let api_member_key_package_events_json = <Vec<String>>::sse_decode(&mut deserializer);
            let api_relay_urls = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::group::create_group(
                            api_name,
                            api_description,
                            api_admin_pubkeys_hex,
                            api_member_key_package_events_json,
                            api_relay_urls,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__create_peer_entry_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_peer_entry",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_participant_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_has_audio_track = <bool>::sse_decode(&mut deserializer);
            let api_has_video_track = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_webrtc::create_peer_entry(
                            api_call_id,
                            api_participant_pubkey_hex,
                            api_has_audio_track,
                            api_has_video_track,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_session__create_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "create_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_call_type = <String>::sse_decode(&mut deserializer);
            let api_direction = <String>::sse_decode(&mut deserializer);
            let api_local_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_remote_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_group_id_hex = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_session::create_session(
                            api_call_id,
                            api_call_type,
                            api_direction,
                            api_local_pubkey_hex,
                            api_remote_pubkey_hex,
                            api_group_id_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__decline_welcome_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decline_welcome",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_welcome_event_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::invite::decline_welcome(api_welcome_event_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__media__decrypt_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decrypt_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_encrypted_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_mime_type = <String>::sse_decode(&mut deserializer);
            let api_filename = <String>::sse_decode(&mut deserializer);
            let api_original_hash_hex = <String>::sse_decode(&mut deserializer);
            let api_nonce_hex = <String>::sse_decode(&mut deserializer);
            let api_scheme_version = <String>::sse_decode(&mut deserializer);
            let api_dimensions = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::media::decrypt_file(
                            api_mls_group_id_hex,
                            api_encrypted_data,
                            api_url,
                            api_mime_type,
                            api_filename,
                            api_original_hash_hex,
                            api_nonce_hex,
                            api_scheme_version,
                            api_dimensions,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__relay__default_relay_urls_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "default_relay_urls",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::relay::default_relay_urls())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__call_webrtc__derive_frame_encryption_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "derive_frame_encryption_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_exporter_secret_hex = <String>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::call_webrtc::derive_frame_encryption_key(
                        api_exporter_secret_hex,
                        api_call_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_session__derive_media_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "derive_media_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_exporter_secret_hex = <String>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::call_session::derive_media_key(
                        api_exporter_secret_hex,
                        api_call_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__state__destroy_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "destroy_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok({
                            crate::api::state::destroy_state().await;
                        })?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__relay__disconnect_relays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "disconnect_relays",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::relay::disconnect_relays().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__media__download_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "download_media",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_url = <String>::sse_decode(&mut deserializer);
            let api_mime_type = <String>::sse_decode(&mut deserializer);
            let api_filename = <String>::sse_decode(&mut deserializer);
            let api_original_hash_hex = <String>::sse_decode(&mut deserializer);
            let api_nonce_hex = <String>::sse_decode(&mut deserializer);
            let api_scheme_version = <String>::sse_decode(&mut deserializer);
            let api_dimensions = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::media::download_media(
                            api_mls_group_id_hex,
                            api_url,
                            api_mime_type,
                            api_filename,
                            api_original_hash_hex,
                            api_nonce_hex,
                            api_scheme_version,
                            api_dimensions,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__media__encrypt_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "encrypt_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_file_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_mime_type = <String>::sse_decode(&mut deserializer);
            let api_filename = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::media::encrypt_file(
                            api_mls_group_id_hex,
                            api_file_data,
                            api_mime_type,
                            api_filename,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_signaling__end_call_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "end_call",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_remote_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::end_call(
                            api_call_id,
                            api_remote_pubkey_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__identity__export_npub_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_npub",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::identity::export_npub().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__identity__export_nsec_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_nsec",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::identity::export_nsec().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__identity__export_pubkey_hex_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "export_pubkey_hex",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::identity::export_pubkey_hex().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__fetch_key_package_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_key_package",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::invite::fetch_key_package(api_pubkey_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__identity__fetch_profile_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fetch_profile",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::identity::fetch_profile(api_pubkey_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__keypackage__generate_key_package_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_key_package",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_relay_urls = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::keypackage::generate_key_package(api_relay_urls).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__generate_webrtc_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "generate_webrtc_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::call_webrtc::generate_webrtc_config(api_call_id)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_session__get_active_calls_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_active_calls",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_session::get_active_calls().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_quality__get_adaptive_bitrate_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_adaptive_bitrate_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::call_quality::get_adaptive_bitrate_config(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_quality__get_audio_constraints_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_audio_constraints",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mode = <crate::api::call_quality::AudioMode>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::call_quality::get_audio_constraints(api_mode),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_webrtc__get_call_participants_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_call_participants",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_webrtc::get_call_participants(api_call_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_quality__get_codec_preferences_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_codec_preferences",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::call_quality::get_codec_preferences())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__account__get_current_account_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_current_account",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::account::get_current_account().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__get_group_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_group",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::group::get_group(api_mls_group_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__get_group_members_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_group_members",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::group::get_group_members(api_mls_group_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__message__get_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_event_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::message::get_message(
                            api_mls_group_id_hex,
                            api_event_id_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__message__get_messages_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_messages",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_limit = <Option<u32>>::sse_decode(&mut deserializer);
            let api_offset = <Option<u32>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::message::get_messages(
                            api_mls_group_id_hex,
                            api_limit,
                            api_offset,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__get_peer_stats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_peer_stats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_participant_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_webrtc::get_peer_stats(api_participant_pubkey_hex)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_session__get_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_session::get_session(api_call_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__get_sfu_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_sfu_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_local_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok =
                        crate::api::call_webrtc::get_sfu_config(api_call_id, api_local_pubkey_hex)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_quality__get_simulcast_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_simulcast_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::call_quality::get_simulcast_config())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_quality__get_video_constraints_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_video_constraints",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_preset =
                <crate::api::call_quality::VideoQualityPreset>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::call_quality::get_video_constraints(api_preset),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__simple__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::simple::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__message__group_message_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "group_message_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::message::group_message_filter(api_mls_group_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__simple__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::simple::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__state__init_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_keys = <Keys>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::state::init_state(api_keys).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_signaling__initiate_call_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "initiate_call",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sdp_offer = <String>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_call_type = <String>::sse_decode(&mut deserializer);
            let api_recipient_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::initiate_call(
                            api_sdp_offer,
                            api_call_id,
                            api_call_type,
                            api_recipient_pubkey_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__state__is_initialized_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_initialized",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::state::is_initialized().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__account__is_logged_in_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_logged_in",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::account::is_logged_in().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__leave_group_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "leave_group",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::group::leave_group(api_mls_group_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__list_groups_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_groups",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::group::list_groups().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__list_pending_welcomes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_pending_welcomes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::invite::list_pending_welcomes().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__relay__list_relays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_relays",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::relay::list_relays().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__account__load_account_from_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_account_from_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::account::load_account_from_file(api_file_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__account__login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_secret_key = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::account::login(api_secret_key).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__account__logout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "logout",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::account::logout().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__merge_pending_commit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "merge_pending_commit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::group::merge_pending_commit(api_mls_group_id_hex).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__media__parse_imeta_tag_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_imeta_tag",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_tag_values = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::media::parse_imeta_tag(api_tag_values)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_webrtc__parse_sdp_answer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_sdp_answer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sdp = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::call_webrtc::parse_sdp_answer(api_sdp)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_webrtc__parse_sdp_offer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_sdp_offer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sdp = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::call_webrtc::parse_sdp_offer(api_sdp)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_signaling__process_call_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "process_call_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_signaling::process_call_event(api_event_json).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__message__process_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "process_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::message::process_message(api_event_json).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__process_welcome_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "process_welcome",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_wrapper_event_id_hex = <String>::sse_decode(&mut deserializer);
            let api_welcome_rumor_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::invite::process_welcome(
                            api_wrapper_event_id_hex,
                            api_welcome_rumor_json,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__identity__profile_data_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "profile_data_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::identity::ProfileData::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__relay__publish_event_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "publish_event_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_event_json = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::relay::publish_event_json(api_event_json).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__keypackage__publish_key_package_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "publish_key_package",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_relay_urls = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::keypackage::publish_key_package(api_relay_urls).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_quality__recommend_quality_preset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "recommend_quality_preset",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_quality_score = <f64>::sse_decode(&mut deserializer);
            let api_estimated_bandwidth_kbps = <f64>::sse_decode(&mut deserializer);
            let api_participant_count = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::call_quality::recommend_quality_preset(
                            api_quality_score,
                            api_estimated_bandwidth_kbps,
                            api_participant_count,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_signaling__reject_call_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reject_call",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_caller_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_reason = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::reject_call(
                            api_call_id,
                            api_caller_pubkey_hex,
                            api_reason,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__remove_call_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_call_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_webrtc::remove_call_peers(api_call_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__invite__remove_members_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_members",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_pubkeys_hex = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::invite::remove_members(
                            api_mls_group_id_hex,
                            api_pubkeys_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__relay__remove_relay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_relay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::relay::remove_relay(api_url).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_session__remove_session_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "remove_session",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_session::remove_session(api_call_id).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__report_peer_stats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "report_peer_stats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_participant_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_rtt_ms = <Option<f64>>::sse_decode(&mut deserializer);
            let api_packet_loss_percent = <Option<f64>>::sse_decode(&mut deserializer);
            let api_outgoing_bitrate_kbps = <Option<f64>>::sse_decode(&mut deserializer);
            let api_incoming_bitrate_kbps = <Option<f64>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_webrtc::report_peer_stats(
                            api_participant_pubkey_hex,
                            api_rtt_ms,
                            api_packet_loss_percent,
                            api_outgoing_bitrate_kbps,
                            api_incoming_bitrate_kbps,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__rotate_frame_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rotate_frame_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_current_key_hex = <String>::sse_decode(&mut deserializer);
            let api_new_epoch = <u64>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, crate::api::error::BurrowError>((move || {
                    let output_ok = crate::api::call_webrtc::rotate_frame_key(
                        api_current_key_hex,
                        api_new_epoch,
                        api_call_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__simple__rust_lib_version_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rust_lib_version",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::simple::rust_lib_version())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__account__save_secret_key_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_secret_key",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_file_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::account::save_secret_key(api_file_path).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_signaling__send_call_state_update_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_call_state_update",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_remote_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_is_muted = <Option<bool>>::sse_decode(&mut deserializer);
            let api_is_video_enabled = <Option<bool>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::send_call_state_update(
                            api_call_id,
                            api_remote_pubkey_hex,
                            api_is_muted,
                            api_is_video_enabled,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_signaling__send_ice_candidate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_ice_candidate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_candidate = <String>::sse_decode(&mut deserializer);
            let api_sdp_mid = <Option<String>>::sse_decode(&mut deserializer);
            let api_sdp_m_line_index = <Option<u32>>::sse_decode(&mut deserializer);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_remote_pubkey_hex = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::send_ice_candidate(
                            api_candidate,
                            api_sdp_mid,
                            api_sdp_m_line_index,
                            api_call_id,
                            api_remote_pubkey_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__message__send_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "send_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_content = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::message::send_message(api_mls_group_id_hex, api_content)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__keypackage__set_key_package_relays_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_key_package_relays",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_relay_urls = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::keypackage::set_key_package_relays(api_relay_urls).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_session__set_muted_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_muted",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_muted = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_session::set_muted(api_call_id, api_muted).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__identity__set_profile_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_profile",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_profile = <crate::api::identity::ProfileData>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::identity::set_profile(api_profile).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_session__set_video_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_video_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_session::set_video_enabled(api_call_id, api_enabled)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__should_use_sfu_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "should_use_sfu",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_participant_count = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::call_webrtc::should_use_sfu(
                        api_participant_count,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__call_signaling__subscribe_call_events_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_call_events",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_signaling::subscribe_call_events().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__group__update_group_name_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_group_name",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::group::update_group_name(api_mls_group_id_hex, api_name)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_webrtc__update_peer_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_peer_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_participant_pubkey_hex = <String>::sse_decode(&mut deserializer);
            let api_state = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::call_webrtc::update_peer_state(
                            api_call_id,
                            api_participant_pubkey_hex,
                            api_state,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__call_session__update_session_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "update_session_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_call_id = <String>::sse_decode(&mut deserializer);
            let api_state = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok =
                            crate::api::call_session::update_session_state(api_call_id, api_state)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__media__upload_media_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "upload_media",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mls_group_id_hex = <String>::sse_decode(&mut deserializer);
            let api_file_data = <Vec<u8>>::sse_decode(&mut deserializer);
            let api_mime_type = <String>::sse_decode(&mut deserializer);
            let api_filename = <String>::sse_decode(&mut deserializer);
            let api_blossom_server_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, crate::api::error::BurrowError>(
                    (move || async move {
                        let output_ok = crate::api::media::upload_media(
                            api_mls_group_id_hex,
                            api_file_data,
                            api_mime_type,
                            api_filename,
                            api_blossom_server_url,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK<MdkMemoryStorage>>
);

// Section: dart2rust

impl SseDecode for BurrowState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Client {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Keys {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MDK<MdkMemoryStorage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK<MdkMemoryStorage>>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK<MdkMemoryStorage>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pubkeyHex = <String>::sse_decode(deserializer);
        let mut var_npub = <String>::sse_decode(deserializer);
        return crate::api::account::AccountInfo {
            pubkey_hex: var_pubkeyHex,
            npub: var_npub,
        };
    }
}

impl SseDecode for crate::api::call_quality::AdaptiveBitrateConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_degradationThresholdBps = <u32>::sse_decode(deserializer);
        let mut var_recoveryThresholdBps = <u32>::sse_decode(deserializer);
        let mut var_hysteresisMs = <u32>::sse_decode(deserializer);
        let mut var_qualitySteps = <Vec<String>>::sse_decode(deserializer);
        let mut var_maxTolerableLossPercent = <f64>::sse_decode(deserializer);
        let mut var_maxTolerableRttMs = <f64>::sse_decode(deserializer);
        return crate::api::call_quality::AdaptiveBitrateConfig {
            degradation_threshold_bps: var_degradationThresholdBps,
            recovery_threshold_bps: var_recoveryThresholdBps,
            hysteresis_ms: var_hysteresisMs,
            quality_steps: var_qualitySteps,
            max_tolerable_loss_percent: var_maxTolerableLossPercent,
            max_tolerable_rtt_ms: var_maxTolerableRttMs,
        };
    }
}

impl SseDecode for crate::api::call_quality::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sampleRate = <u32>::sse_decode(deserializer);
        let mut var_channelCount = <u32>::sse_decode(deserializer);
        let mut var_echoCancellation = <bool>::sse_decode(deserializer);
        let mut var_noiseSuppression = <bool>::sse_decode(deserializer);
        let mut var_autoGainControl = <bool>::sse_decode(deserializer);
        let mut var_bitrateBps = <u32>::sse_decode(deserializer);
        let mut var_dtxEnabled = <bool>::sse_decode(deserializer);
        let mut var_fecEnabled = <bool>::sse_decode(deserializer);
        let mut var_ptimeMs = <u32>::sse_decode(deserializer);
        return crate::api::call_quality::AudioConstraints {
            sample_rate: var_sampleRate,
            channel_count: var_channelCount,
            echo_cancellation: var_echoCancellation,
            noise_suppression: var_noiseSuppression,
            auto_gain_control: var_autoGainControl,
            bitrate_bps: var_bitrateBps,
            dtx_enabled: var_dtxEnabled,
            fec_enabled: var_fecEnabled,
            ptime_ms: var_ptimeMs,
        };
    }
}

impl SseDecode for crate::api::call_quality::AudioMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::call_quality::AudioMode::Voice,
            1 => crate::api::call_quality::AudioMode::Music,
            _ => unreachable!("Invalid variant for AudioMode: {}", inner),
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::error::BurrowError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::api::error::BurrowError {
            message: var_message,
        };
    }
}

impl SseDecode for crate::api::call_session::CallDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::call_session::CallDirection::Outgoing,
            1 => crate::api::call_session::CallDirection::Incoming,
            _ => unreachable!("Invalid variant for CallDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::call_session::CallSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_callId = <String>::sse_decode(deserializer);
        let mut var_state = <crate::api::call_session::CallState>::sse_decode(deserializer);
        let mut var_callType = <crate::api::call_session::CallType>::sse_decode(deserializer);
        let mut var_direction = <crate::api::call_session::CallDirection>::sse_decode(deserializer);
        let mut var_participants = <Vec<String>>::sse_decode(deserializer);
        let mut var_localPubkeyHex = <String>::sse_decode(deserializer);
        let mut var_remotePubkeyHex = <String>::sse_decode(deserializer);
        let mut var_groupIdHex = <Option<String>>::sse_decode(deserializer);
        let mut var_createdAt = <u64>::sse_decode(deserializer);
        let mut var_startedAt = <Option<u64>>::sse_decode(deserializer);
        let mut var_endedAt = <Option<u64>>::sse_decode(deserializer);
        let mut var_isMuted = <bool>::sse_decode(deserializer);
        let mut var_isVideoEnabled = <bool>::sse_decode(deserializer);
        return crate::api::call_session::CallSession {
            call_id: var_callId,
            state: var_state,
            call_type: var_callType,
            direction: var_direction,
            participants: var_participants,
            local_pubkey_hex: var_localPubkeyHex,
            remote_pubkey_hex: var_remotePubkeyHex,
            group_id_hex: var_groupIdHex,
            created_at: var_createdAt,
            started_at: var_startedAt,
            ended_at: var_endedAt,
            is_muted: var_isMuted,
            is_video_enabled: var_isVideoEnabled,
        };
    }
}

impl SseDecode for crate::api::call_signaling::CallSignalingEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_kind = <u32>::sse_decode(deserializer);
        let mut var_senderPubkeyHex = <String>::sse_decode(deserializer);
        let mut var_callId = <String>::sse_decode(deserializer);
        let mut var_callType = <Option<String>>::sse_decode(deserializer);
        let mut var_content = <String>::sse_decode(deserializer);
        let mut var_createdAt = <u64>::sse_decode(deserializer);
        return crate::api::call_signaling::CallSignalingEvent {
            kind: var_kind,
            sender_pubkey_hex: var_senderPubkeyHex,
            call_id: var_callId,
            call_type: var_callType,
            content: var_content,
            created_at: var_createdAt,
        };
    }
}

impl SseDecode for crate::api::call_session::CallState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::call_session::CallState::Idle,
            1 => crate::api::call_session::CallState::Initiating,
            2 => crate::api::call_session::CallState::Ringing,
            3 => crate::api::call_session::CallState::Connecting,
            4 => crate::api::call_session::CallState::Active,
            5 => crate::api::call_session::CallState::Ending,
            6 => crate::api::call_session::CallState::Failed,
            7 => crate::api::call_session::CallState::Rejected,
            _ => unreachable!("Invalid variant for CallState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::call_session::CallType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::call_session::CallType::Audio,
            1 => crate::api::call_session::CallType::Video,
            _ => unreachable!("Invalid variant for CallType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::call_quality::CodecPreferences {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_audioCodecs = <Vec<String>>::sse_decode(deserializer);
        let mut var_videoCodecs = <Vec<String>>::sse_decode(deserializer);
        return crate::api::call_quality::CodecPreferences {
            audio_codecs: var_audioCodecs,
            video_codecs: var_videoCodecs,
        };
    }
}

impl SseDecode for crate::api::group::CreateGroupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_group = <crate::api::group::GroupInfo>::sse_decode(deserializer);
        let mut var_welcomeRumorsJson = <Vec<String>>::sse_decode(deserializer);
        let mut var_mlsGroupIdHex = <String>::sse_decode(deserializer);
        return crate::api::group::CreateGroupResult {
            group: var_group,
            welcome_rumors_json: var_welcomeRumorsJson,
            mls_group_id_hex: var_mlsGroupIdHex,
        };
    }
}

impl SseDecode for crate::api::media::EncryptedFileResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_encryptedData = <Vec<u8>>::sse_decode(deserializer);
        let mut var_originalHashHex = <String>::sse_decode(deserializer);
        let mut var_encryptedHashHex = <String>::sse_decode(deserializer);
        let mut var_mimeType = <String>::sse_decode(deserializer);
        let mut var_filename = <String>::sse_decode(deserializer);
        let mut var_originalSize = <u64>::sse_decode(deserializer);
        let mut var_encryptedSize = <u64>::sse_decode(deserializer);
        let mut var_dimensions = <Option<String>>::sse_decode(deserializer);
        let mut var_blurhash = <Option<String>>::sse_decode(deserializer);
        let mut var_nonceHex = <String>::sse_decode(deserializer);
        return crate::api::media::EncryptedFileResult {
            encrypted_data: var_encryptedData,
            original_hash_hex: var_originalHashHex,
            encrypted_hash_hex: var_encryptedHashHex,
            mime_type: var_mimeType,
            filename: var_filename,
            original_size: var_originalSize,
            encrypted_size: var_encryptedSize,
            dimensions: var_dimensions,
            blurhash: var_blurhash,
            nonce_hex: var_nonceHex,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::group::GroupInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_mlsGroupIdHex = <String>::sse_decode(deserializer);
        let mut var_nostrGroupIdHex = <String>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        let mut var_adminPubkeys = <Vec<String>>::sse_decode(deserializer);
        let mut var_epoch = <u64>::sse_decode(deserializer);
        let mut var_state = <String>::sse_decode(deserializer);
        return crate::api::group::GroupInfo {
            mls_group_id_hex: var_mlsGroupIdHex,
            nostr_group_id_hex: var_nostrGroupIdHex,
            name: var_name,
            description: var_description,
            admin_pubkeys: var_adminPubkeys,
            epoch: var_epoch,
            state: var_state,
        };
    }
}

impl SseDecode for crate::api::message::GroupMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_eventIdHex = <String>::sse_decode(deserializer);
        let mut var_authorPubkeyHex = <String>::sse_decode(deserializer);
        let mut var_content = <String>::sse_decode(deserializer);
        let mut var_createdAt = <u64>::sse_decode(deserializer);
        let mut var_mlsGroupIdHex = <String>::sse_decode(deserializer);
        let mut var_kind = <u64>::sse_decode(deserializer);
        let mut var_tags = <Vec<Vec<String>>>::sse_decode(deserializer);
        let mut var_wrapperEventIdHex = <String>::sse_decode(deserializer);
        let mut var_epoch = <u64>::sse_decode(deserializer);
        return crate::api::message::GroupMessage {
            event_id_hex: var_eventIdHex,
            author_pubkey_hex: var_authorPubkeyHex,
            content: var_content,
            created_at: var_createdAt,
            mls_group_id_hex: var_mlsGroupIdHex,
            kind: var_kind,
            tags: var_tags,
            wrapper_event_id_hex: var_wrapperEventIdHex,
            epoch: var_epoch,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::call_webrtc::IceServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_urls = <Vec<String>>::sse_decode(deserializer);
        let mut var_username = <Option<String>>::sse_decode(deserializer);
        let mut var_credential = <Option<String>>::sse_decode(deserializer);
        return crate::api::call_webrtc::IceServer {
            urls: var_urls,
            username: var_username,
            credential: var_credential,
        };
    }
}

impl SseDecode for crate::api::keypackage::KeyPackageData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_keyPackageBase64 = <String>::sse_decode(deserializer);
        let mut var_tags = <Vec<Vec<String>>>::sse_decode(deserializer);
        return crate::api::keypackage::KeyPackageData {
            key_package_base64: var_keyPackageBase64,
            tags: var_tags,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::call_session::CallSession> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::call_session::CallSession>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::group::GroupInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::group::GroupInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::message::GroupMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::message::GroupMessage>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::call_webrtc::IceServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::call_webrtc::IceServer>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<String>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::group::MemberInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::group::MemberInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::call_webrtc::PeerEntry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::call_webrtc::PeerEntry>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::relay::RelayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::relay::RelayInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::call_quality::SimulcastLayer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::call_quality::SimulcastLayer>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::invite::WelcomeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::invite::WelcomeInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::media::MediaReferenceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_originalHashHex = <String>::sse_decode(deserializer);
        let mut var_mimeType = <String>::sse_decode(deserializer);
        let mut var_filename = <String>::sse_decode(deserializer);
        let mut var_dimensions = <Option<String>>::sse_decode(deserializer);
        let mut var_schemeVersion = <String>::sse_decode(deserializer);
        let mut var_nonceHex = <String>::sse_decode(deserializer);
        return crate::api::media::MediaReferenceInfo {
            url: var_url,
            original_hash_hex: var_originalHashHex,
            mime_type: var_mimeType,
            filename: var_filename,
            dimensions: var_dimensions,
            scheme_version: var_schemeVersion,
            nonce_hex: var_nonceHex,
        };
    }
}

impl SseDecode for crate::api::group::MemberInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_pubkeyHex = <String>::sse_decode(deserializer);
        return crate::api::group::MemberInfo {
            pubkey_hex: var_pubkeyHex,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::call_session::CallSession> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::call_session::CallSession>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::call_signaling::CallSignalingEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::call_signaling::CallSignalingEvent>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::message::GroupMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::message::GroupMessage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::call_webrtc::PeerStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::call_webrtc::PeerStats>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::call_webrtc::PeerConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::call_webrtc::PeerConnectionState::New,
            1 => crate::api::call_webrtc::PeerConnectionState::Checking,
            2 => crate::api::call_webrtc::PeerConnectionState::Connected,
            3 => crate::api::call_webrtc::PeerConnectionState::Disconnected,
            4 => crate::api::call_webrtc::PeerConnectionState::Failed,
            5 => crate::api::call_webrtc::PeerConnectionState::Closed,
            _ => unreachable!("Invalid variant for PeerConnectionState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::call_webrtc::PeerEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_participantPubkeyHex = <String>::sse_decode(deserializer);
        let mut var_connectionState =
            <crate::api::call_webrtc::PeerConnectionState>::sse_decode(deserializer);
        let mut var_callId = <String>::sse_decode(deserializer);
        let mut var_hasAudioTrack = <bool>::sse_decode(deserializer);
        let mut var_hasVideoTrack = <bool>::sse_decode(deserializer);
        let mut var_isRemoteMuted = <bool>::sse_decode(deserializer);
        let mut var_isRemoteVideoEnabled = <bool>::sse_decode(deserializer);
        let mut var_createdAt = <u64>::sse_decode(deserializer);
        let mut var_updatedAt = <u64>::sse_decode(deserializer);
        return crate::api::call_webrtc::PeerEntry {
            participant_pubkey_hex: var_participantPubkeyHex,
            connection_state: var_connectionState,
            call_id: var_callId,
            has_audio_track: var_hasAudioTrack,
            has_video_track: var_hasVideoTrack,
            is_remote_muted: var_isRemoteMuted,
            is_remote_video_enabled: var_isRemoteVideoEnabled,
            created_at: var_createdAt,
            updated_at: var_updatedAt,
        };
    }
}

impl SseDecode for crate::api::call_webrtc::PeerStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_participantPubkeyHex = <String>::sse_decode(deserializer);
        let mut var_rttMs = <Option<f64>>::sse_decode(deserializer);
        let mut var_packetLossPercent = <Option<f64>>::sse_decode(deserializer);
        let mut var_outgoingBitrateKbps = <Option<f64>>::sse_decode(deserializer);
        let mut var_incomingBitrateKbps = <Option<f64>>::sse_decode(deserializer);
        let mut var_qualityScore = <Option<f64>>::sse_decode(deserializer);
        let mut var_timestamp = <u64>::sse_decode(deserializer);
        return crate::api::call_webrtc::PeerStats {
            participant_pubkey_hex: var_participantPubkeyHex,
            rtt_ms: var_rttMs,
            packet_loss_percent: var_packetLossPercent,
            outgoing_bitrate_kbps: var_outgoingBitrateKbps,
            incoming_bitrate_kbps: var_incomingBitrateKbps,
            quality_score: var_qualityScore,
            timestamp: var_timestamp,
        };
    }
}

impl SseDecode for crate::api::message::ProcessMessageResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_resultType = <String>::sse_decode(deserializer);
        let mut var_message = <Option<crate::api::message::GroupMessage>>::sse_decode(deserializer);
        let mut var_mlsGroupIdHex = <String>::sse_decode(deserializer);
        let mut var_evolutionEventJson = <Option<String>>::sse_decode(deserializer);
        return crate::api::message::ProcessMessageResult {
            result_type: var_resultType,
            message: var_message,
            mls_group_id_hex: var_mlsGroupIdHex,
            evolution_event_json: var_evolutionEventJson,
        };
    }
}

impl SseDecode for crate::api::identity::ProfileData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_displayName = <Option<String>>::sse_decode(deserializer);
        let mut var_about = <Option<String>>::sse_decode(deserializer);
        let mut var_picture = <Option<String>>::sse_decode(deserializer);
        let mut var_nip05 = <Option<String>>::sse_decode(deserializer);
        let mut var_lud16 = <Option<String>>::sse_decode(deserializer);
        return crate::api::identity::ProfileData {
            name: var_name,
            display_name: var_displayName,
            about: var_about,
            picture: var_picture,
            nip05: var_nip05,
            lud16: var_lud16,
        };
    }
}

impl SseDecode for crate::api::call_quality::QualityRecommendation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_preset = <String>::sse_decode(deserializer);
        let mut var_audioMode = <String>::sse_decode(deserializer);
        let mut var_useSimulcast = <bool>::sse_decode(deserializer);
        let mut var_reason = <String>::sse_decode(deserializer);
        return crate::api::call_quality::QualityRecommendation {
            preset: var_preset,
            audio_mode: var_audioMode,
            use_simulcast: var_useSimulcast,
            reason: var_reason,
        };
    }
}

impl SseDecode for crate::api::call_quality::QualityScore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_score = <f64>::sse_decode(deserializer);
        let mut var_label = <String>::sse_decode(deserializer);
        let mut var_rttScore = <f64>::sse_decode(deserializer);
        let mut var_jitterScore = <f64>::sse_decode(deserializer);
        let mut var_lossScore = <f64>::sse_decode(deserializer);
        let mut var_bitrateScore = <f64>::sse_decode(deserializer);
        return crate::api::call_quality::QualityScore {
            score: var_score,
            label: var_label,
            rtt_score: var_rttScore,
            jitter_score: var_jitterScore,
            loss_score: var_lossScore,
            bitrate_score: var_bitrateScore,
        };
    }
}

impl SseDecode for crate::api::relay::RelayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_connected = <bool>::sse_decode(deserializer);
        return crate::api::relay::RelayInfo {
            url: var_url,
            connected: var_connected,
        };
    }
}

impl SseDecode for crate::api::call_webrtc::SdpInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sdpType = <String>::sse_decode(deserializer);
        let mut var_hasAudio = <bool>::sse_decode(deserializer);
        let mut var_hasVideo = <bool>::sse_decode(deserializer);
        let mut var_mediaCount = <u32>::sse_decode(deserializer);
        let mut var_iceUfrag = <Option<String>>::sse_decode(deserializer);
        let mut var_codecs = <Vec<String>>::sse_decode(deserializer);
        let mut var_isValid = <bool>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::api::call_webrtc::SdpInfo {
            sdp_type: var_sdpType,
            has_audio: var_hasAudio,
            has_video: var_hasVideo,
            media_count: var_mediaCount,
            ice_ufrag: var_iceUfrag,
            codecs: var_codecs,
            is_valid: var_isValid,
            error: var_error,
        };
    }
}

impl SseDecode for crate::api::call_webrtc::SfuConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_serverUrl = <String>::sse_decode(deserializer);
        let mut var_roomName = <String>::sse_decode(deserializer);
        let mut var_token = <String>::sse_decode(deserializer);
        return crate::api::call_webrtc::SfuConfig {
            server_url: var_serverUrl,
            room_name: var_roomName,
            token: var_token,
        };
    }
}

impl SseDecode for crate::api::call_quality::SimulcastConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_layers =
            <Vec<crate::api::call_quality::SimulcastLayer>>::sse_decode(deserializer);
        return crate::api::call_quality::SimulcastConfig {
            enabled: var_enabled,
            layers: var_layers,
        };
    }
}

impl SseDecode for crate::api::call_quality::SimulcastLayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rid = <String>::sse_decode(deserializer);
        let mut var_width = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_frameRate = <u32>::sse_decode(deserializer);
        let mut var_maxBitrateBps = <u32>::sse_decode(deserializer);
        let mut var_scaleResolutionDownBy = <f64>::sse_decode(deserializer);
        return crate::api::call_quality::SimulcastLayer {
            rid: var_rid,
            width: var_width,
            height: var_height,
            frame_rate: var_frameRate,
            max_bitrate_bps: var_maxBitrateBps,
            scale_resolution_down_by: var_scaleResolutionDownBy,
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::group::UpdateGroupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_evolutionEventJson = <String>::sse_decode(deserializer);
        let mut var_welcomeRumorsJson = <Vec<String>>::sse_decode(deserializer);
        let mut var_mlsGroupIdHex = <String>::sse_decode(deserializer);
        return crate::api::group::UpdateGroupResult {
            evolution_event_json: var_evolutionEventJson,
            welcome_rumors_json: var_welcomeRumorsJson,
            mls_group_id_hex: var_mlsGroupIdHex,
        };
    }
}

impl SseDecode for crate::api::media::UploadMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_url = <String>::sse_decode(deserializer);
        let mut var_imetaTagValues = <Vec<String>>::sse_decode(deserializer);
        let mut var_reference = <crate::api::media::MediaReferenceInfo>::sse_decode(deserializer);
        return crate::api::media::UploadMediaResult {
            url: var_url,
            imeta_tag_values: var_imetaTagValues,
            reference: var_reference,
        };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::call_quality::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_width = <u32>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        let mut var_frameRate = <u32>::sse_decode(deserializer);
        let mut var_maxBitrateBps = <u32>::sse_decode(deserializer);
        let mut var_minBitrateBps = <u32>::sse_decode(deserializer);
        let mut var_preferredCodec = <String>::sse_decode(deserializer);
        let mut var_hardwareAcceleration = <bool>::sse_decode(deserializer);
        return crate::api::call_quality::VideoConstraints {
            width: var_width,
            height: var_height,
            frame_rate: var_frameRate,
            max_bitrate_bps: var_maxBitrateBps,
            min_bitrate_bps: var_minBitrateBps,
            preferred_codec: var_preferredCodec,
            hardware_acceleration: var_hardwareAcceleration,
        };
    }
}

impl SseDecode for crate::api::call_quality::VideoQualityPreset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::call_quality::VideoQualityPreset::Low,
            1 => crate::api::call_quality::VideoQualityPreset::Medium,
            2 => crate::api::call_quality::VideoQualityPreset::High,
            3 => crate::api::call_quality::VideoQualityPreset::Hd,
            _ => unreachable!("Invalid variant for VideoQualityPreset: {}", inner),
        };
    }
}

impl SseDecode for crate::api::call_webrtc::WebRtcConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_iceServers =
            <Vec<crate::api::call_webrtc::IceServer>>::sse_decode(deserializer);
        let mut var_sdpSemantics = <String>::sse_decode(deserializer);
        let mut var_bundlePolicy = <String>::sse_decode(deserializer);
        return crate::api::call_webrtc::WebRtcConfig {
            ice_servers: var_iceServers,
            sdp_semantics: var_sdpSemantics,
            bundle_policy: var_bundlePolicy,
        };
    }
}

impl SseDecode for crate::api::invite::WelcomeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_welcomeEventId = <String>::sse_decode(deserializer);
        let mut var_mlsGroupIdHex = <String>::sse_decode(deserializer);
        let mut var_nostrGroupIdHex = <String>::sse_decode(deserializer);
        let mut var_groupName = <String>::sse_decode(deserializer);
        let mut var_groupDescription = <String>::sse_decode(deserializer);
        let mut var_welcomerPubkeyHex = <String>::sse_decode(deserializer);
        let mut var_memberCount = <u32>::sse_decode(deserializer);
        let mut var_state = <String>::sse_decode(deserializer);
        return crate::api::invite::WelcomeInfo {
            welcome_event_id: var_welcomeEventId,
            mls_group_id_hex: var_mlsGroupIdHex,
            nostr_group_id_hex: var_nostrGroupIdHex,
            group_name: var_groupName,
            group_description: var_groupDescription,
            welcomer_pubkey_hex: var_welcomerPubkeyHex,
            member_count: var_memberCount,
            state: var_state,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        7 => wire__crate__api__call_signaling__accept_call_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__invite__accept_welcome_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__invite__add_members_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__relay__add_relay_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__call_signaling__build_group_call_signaling_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        12 => wire__crate__api__media__build_imeta_tag_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__call_quality__calculate_quality_score_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        14 => wire__crate__api__relay__connect_relays_impl(port, ptr, rust_vec_len, data_len),
        15 => wire__crate__api__account__create_account_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__group__create_group_impl(port, ptr, rust_vec_len, data_len),
        17 => {
            wire__crate__api__call_webrtc__create_peer_entry_impl(port, ptr, rust_vec_len, data_len)
        }
        18 => {
            wire__crate__api__call_session__create_session_impl(port, ptr, rust_vec_len, data_len)
        }
        19 => wire__crate__api__invite__decline_welcome_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__media__decrypt_file_impl(port, ptr, rust_vec_len, data_len),
        22 => wire__crate__api__call_webrtc__derive_frame_encryption_key_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        23 => {
            wire__crate__api__call_session__derive_media_key_impl(port, ptr, rust_vec_len, data_len)
        }
        24 => wire__crate__api__state__destroy_state_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__relay__disconnect_relays_impl(port, ptr, rust_vec_len, data_len),
        26 => wire__crate__api__media__download_media_impl(port, ptr, rust_vec_len, data_len),
        27 => wire__crate__api__media__encrypt_file_impl(port, ptr, rust_vec_len, data_len),
        28 => wire__crate__api__call_signaling__end_call_impl(port, ptr, rust_vec_len, data_len),
        29 => wire__crate__api__identity__export_npub_impl(port, ptr, rust_vec_len, data_len),
        30 => wire__crate__api__identity__export_nsec_impl(port, ptr, rust_vec_len, data_len),
        31 => wire__crate__api__identity__export_pubkey_hex_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__invite__fetch_key_package_impl(port, ptr, rust_vec_len, data_len),
        33 => wire__crate__api__identity__fetch_profile_impl(port, ptr, rust_vec_len, data_len),
        34 => wire__crate__api__keypackage__generate_key_package_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        35 => wire__crate__api__call_webrtc__generate_webrtc_config_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        36 => {
            wire__crate__api__call_session__get_active_calls_impl(port, ptr, rust_vec_len, data_len)
        }
        37 => wire__crate__api__call_quality__get_adaptive_bitrate_config_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        38 => wire__crate__api__call_quality__get_audio_constraints_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        39 => wire__crate__api__call_webrtc__get_call_participants_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        40 => wire__crate__api__call_quality__get_codec_preferences_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        41 => {
            wire__crate__api__account__get_current_account_impl(port, ptr, rust_vec_len, data_len)
        }
        42 => wire__crate__api__group__get_group_impl(port, ptr, rust_vec_len, data_len),
        43 => wire__crate__api__group__get_group_members_impl(port, ptr, rust_vec_len, data_len),
        44 => wire__crate__api__message__get_message_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__message__get_messages_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__call_webrtc__get_peer_stats_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__call_session__get_session_impl(port, ptr, rust_vec_len, data_len),
        48 => wire__crate__api__call_webrtc__get_sfu_config_impl(port, ptr, rust_vec_len, data_len),
        49 => wire__crate__api__call_quality__get_simulcast_config_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        50 => wire__crate__api__call_quality__get_video_constraints_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        52 => {
            wire__crate__api__message__group_message_filter_impl(port, ptr, rust_vec_len, data_len)
        }
        53 => wire__crate__api__simple__init_app_impl(port, ptr, rust_vec_len, data_len),
        54 => wire__crate__api__state__init_state_impl(port, ptr, rust_vec_len, data_len),
        55 => {
            wire__crate__api__call_signaling__initiate_call_impl(port, ptr, rust_vec_len, data_len)
        }
        56 => wire__crate__api__state__is_initialized_impl(port, ptr, rust_vec_len, data_len),
        57 => wire__crate__api__account__is_logged_in_impl(port, ptr, rust_vec_len, data_len),
        58 => wire__crate__api__group__leave_group_impl(port, ptr, rust_vec_len, data_len),
        59 => wire__crate__api__group__list_groups_impl(port, ptr, rust_vec_len, data_len),
        60 => {
            wire__crate__api__invite__list_pending_welcomes_impl(port, ptr, rust_vec_len, data_len)
        }
        61 => wire__crate__api__relay__list_relays_impl(port, ptr, rust_vec_len, data_len),
        62 => wire__crate__api__account__load_account_from_file_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        63 => wire__crate__api__account__login_impl(port, ptr, rust_vec_len, data_len),
        64 => wire__crate__api__account__logout_impl(port, ptr, rust_vec_len, data_len),
        65 => wire__crate__api__group__merge_pending_commit_impl(port, ptr, rust_vec_len, data_len),
        66 => wire__crate__api__media__parse_imeta_tag_impl(port, ptr, rust_vec_len, data_len),
        67 => {
            wire__crate__api__call_webrtc__parse_sdp_answer_impl(port, ptr, rust_vec_len, data_len)
        }
        68 => {
            wire__crate__api__call_webrtc__parse_sdp_offer_impl(port, ptr, rust_vec_len, data_len)
        }
        69 => wire__crate__api__call_signaling__process_call_event_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        70 => wire__crate__api__message__process_message_impl(port, ptr, rust_vec_len, data_len),
        71 => wire__crate__api__invite__process_welcome_impl(port, ptr, rust_vec_len, data_len),
        72 => {
            wire__crate__api__identity__profile_data_default_impl(port, ptr, rust_vec_len, data_len)
        }
        73 => wire__crate__api__relay__publish_event_json_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__keypackage__publish_key_package_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        75 => wire__crate__api__call_quality__recommend_quality_preset_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        76 => wire__crate__api__call_signaling__reject_call_impl(port, ptr, rust_vec_len, data_len),
        77 => {
            wire__crate__api__call_webrtc__remove_call_peers_impl(port, ptr, rust_vec_len, data_len)
        }
        78 => wire__crate__api__invite__remove_members_impl(port, ptr, rust_vec_len, data_len),
        79 => wire__crate__api__relay__remove_relay_impl(port, ptr, rust_vec_len, data_len),
        80 => {
            wire__crate__api__call_session__remove_session_impl(port, ptr, rust_vec_len, data_len)
        }
        81 => {
            wire__crate__api__call_webrtc__report_peer_stats_impl(port, ptr, rust_vec_len, data_len)
        }
        82 => {
            wire__crate__api__call_webrtc__rotate_frame_key_impl(port, ptr, rust_vec_len, data_len)
        }
        84 => wire__crate__api__account__save_secret_key_impl(port, ptr, rust_vec_len, data_len),
        85 => wire__crate__api__call_signaling__send_call_state_update_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        86 => wire__crate__api__call_signaling__send_ice_candidate_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        87 => wire__crate__api__message__send_message_impl(port, ptr, rust_vec_len, data_len),
        88 => wire__crate__api__keypackage__set_key_package_relays_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        89 => wire__crate__api__call_session__set_muted_impl(port, ptr, rust_vec_len, data_len),
        90 => wire__crate__api__identity__set_profile_impl(port, ptr, rust_vec_len, data_len),
        91 => wire__crate__api__call_session__set_video_enabled_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        92 => wire__crate__api__call_webrtc__should_use_sfu_impl(port, ptr, rust_vec_len, data_len),
        93 => wire__crate__api__call_signaling__subscribe_call_events_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        94 => wire__crate__api__group__update_group_name_impl(port, ptr, rust_vec_len, data_len),
        95 => {
            wire__crate__api__call_webrtc__update_peer_state_impl(port, ptr, rust_vec_len, data_len)
        }
        96 => wire__crate__api__call_session__update_session_state_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        97 => wire__crate__api__media__upload_media_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__state__BurrowState_auto_accessor_get_client_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        2 => wire__crate__api__state__BurrowState_auto_accessor_get_keys_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        3 => wire__crate__api__state__BurrowState_auto_accessor_get_mdk_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        4 => wire__crate__api__state__BurrowState_auto_accessor_set_client_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__state__BurrowState_auto_accessor_set_keys_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__state__BurrowState_auto_accessor_set_mdk_impl(
            ptr,
            rust_vec_len,
            data_len,
        ),
        21 => wire__crate__api__relay__default_relay_urls_impl(ptr, rust_vec_len, data_len),
        51 => wire__crate__api__simple__greet_impl(ptr, rust_vec_len, data_len),
        83 => wire__crate__api__simple__rust_lib_version_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BurrowState> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BurrowState> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BurrowState>> for BurrowState {
    fn into_into_dart(self) -> FrbWrapper<BurrowState> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Client> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Client> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Client>> for Client {
    fn into_into_dart(self) -> FrbWrapper<Client> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Keys> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Keys> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Keys>> for Keys {
    fn into_into_dart(self) -> FrbWrapper<Keys> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MDK<MdkMemoryStorage>> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MDK<MdkMemoryStorage>>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MDK<MdkMemoryStorage>>>
    for MDK<MdkMemoryStorage>
{
    fn into_into_dart(self) -> FrbWrapper<MDK<MdkMemoryStorage>> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::account::AccountInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pubkey_hex.into_into_dart().into_dart(),
            self.npub.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::account::AccountInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::account::AccountInfo>
    for crate::api::account::AccountInfo
{
    fn into_into_dart(self) -> crate::api::account::AccountInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::AdaptiveBitrateConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.degradation_threshold_bps.into_into_dart().into_dart(),
            self.recovery_threshold_bps.into_into_dart().into_dart(),
            self.hysteresis_ms.into_into_dart().into_dart(),
            self.quality_steps.into_into_dart().into_dart(),
            self.max_tolerable_loss_percent.into_into_dart().into_dart(),
            self.max_tolerable_rtt_ms.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::AdaptiveBitrateConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::AdaptiveBitrateConfig>
    for crate::api::call_quality::AdaptiveBitrateConfig
{
    fn into_into_dart(self) -> crate::api::call_quality::AdaptiveBitrateConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::AudioConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sample_rate.into_into_dart().into_dart(),
            self.channel_count.into_into_dart().into_dart(),
            self.echo_cancellation.into_into_dart().into_dart(),
            self.noise_suppression.into_into_dart().into_dart(),
            self.auto_gain_control.into_into_dart().into_dart(),
            self.bitrate_bps.into_into_dart().into_dart(),
            self.dtx_enabled.into_into_dart().into_dart(),
            self.fec_enabled.into_into_dart().into_dart(),
            self.ptime_ms.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::AudioConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::AudioConstraints>
    for crate::api::call_quality::AudioConstraints
{
    fn into_into_dart(self) -> crate::api::call_quality::AudioConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::AudioMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Voice => 0.into_dart(),
            Self::Music => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::AudioMode
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::AudioMode>
    for crate::api::call_quality::AudioMode
{
    fn into_into_dart(self) -> crate::api::call_quality::AudioMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::BurrowError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.message.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::error::BurrowError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::BurrowError>
    for crate::api::error::BurrowError
{
    fn into_into_dart(self) -> crate::api::error::BurrowError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_session::CallDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Outgoing => 0.into_dart(),
            Self::Incoming => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_session::CallDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_session::CallDirection>
    for crate::api::call_session::CallDirection
{
    fn into_into_dart(self) -> crate::api::call_session::CallDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_session::CallSession {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.call_id.into_into_dart().into_dart(),
            self.state.into_into_dart().into_dart(),
            self.call_type.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.participants.into_into_dart().into_dart(),
            self.local_pubkey_hex.into_into_dart().into_dart(),
            self.remote_pubkey_hex.into_into_dart().into_dart(),
            self.group_id_hex.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.started_at.into_into_dart().into_dart(),
            self.ended_at.into_into_dart().into_dart(),
            self.is_muted.into_into_dart().into_dart(),
            self.is_video_enabled.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_session::CallSession
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_session::CallSession>
    for crate::api::call_session::CallSession
{
    fn into_into_dart(self) -> crate::api::call_session::CallSession {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_signaling::CallSignalingEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.kind.into_into_dart().into_dart(),
            self.sender_pubkey_hex.into_into_dart().into_dart(),
            self.call_id.into_into_dart().into_dart(),
            self.call_type.into_into_dart().into_dart(),
            self.content.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_signaling::CallSignalingEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_signaling::CallSignalingEvent>
    for crate::api::call_signaling::CallSignalingEvent
{
    fn into_into_dart(self) -> crate::api::call_signaling::CallSignalingEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_session::CallState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Idle => 0.into_dart(),
            Self::Initiating => 1.into_dart(),
            Self::Ringing => 2.into_dart(),
            Self::Connecting => 3.into_dart(),
            Self::Active => 4.into_dart(),
            Self::Ending => 5.into_dart(),
            Self::Failed => 6.into_dart(),
            Self::Rejected => 7.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_session::CallState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_session::CallState>
    for crate::api::call_session::CallState
{
    fn into_into_dart(self) -> crate::api::call_session::CallState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_session::CallType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Audio => 0.into_dart(),
            Self::Video => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_session::CallType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_session::CallType>
    for crate::api::call_session::CallType
{
    fn into_into_dart(self) -> crate::api::call_session::CallType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::CodecPreferences {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.audio_codecs.into_into_dart().into_dart(),
            self.video_codecs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::CodecPreferences
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::CodecPreferences>
    for crate::api::call_quality::CodecPreferences
{
    fn into_into_dart(self) -> crate::api::call_quality::CodecPreferences {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::group::CreateGroupResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.group.into_into_dart().into_dart(),
            self.welcome_rumors_json.into_into_dart().into_dart(),
            self.mls_group_id_hex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::group::CreateGroupResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::group::CreateGroupResult>
    for crate::api::group::CreateGroupResult
{
    fn into_into_dart(self) -> crate::api::group::CreateGroupResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media::EncryptedFileResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.encrypted_data.into_into_dart().into_dart(),
            self.original_hash_hex.into_into_dart().into_dart(),
            self.encrypted_hash_hex.into_into_dart().into_dart(),
            self.mime_type.into_into_dart().into_dart(),
            self.filename.into_into_dart().into_dart(),
            self.original_size.into_into_dart().into_dart(),
            self.encrypted_size.into_into_dart().into_dart(),
            self.dimensions.into_into_dart().into_dart(),
            self.blurhash.into_into_dart().into_dart(),
            self.nonce_hex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::EncryptedFileResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media::EncryptedFileResult>
    for crate::api::media::EncryptedFileResult
{
    fn into_into_dart(self) -> crate::api::media::EncryptedFileResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::group::GroupInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.mls_group_id_hex.into_into_dart().into_dart(),
            self.nostr_group_id_hex.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
            self.admin_pubkeys.into_into_dart().into_dart(),
            self.epoch.into_into_dart().into_dart(),
            self.state.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::group::GroupInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::group::GroupInfo>
    for crate::api::group::GroupInfo
{
    fn into_into_dart(self) -> crate::api::group::GroupInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::message::GroupMessage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.event_id_hex.into_into_dart().into_dart(),
            self.author_pubkey_hex.into_into_dart().into_dart(),
            self.content.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.mls_group_id_hex.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.tags.into_into_dart().into_dart(),
            self.wrapper_event_id_hex.into_into_dart().into_dart(),
            self.epoch.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::message::GroupMessage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::message::GroupMessage>
    for crate::api::message::GroupMessage
{
    fn into_into_dart(self) -> crate::api::message::GroupMessage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::IceServer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.urls.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.credential.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::IceServer
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::IceServer>
    for crate::api::call_webrtc::IceServer
{
    fn into_into_dart(self) -> crate::api::call_webrtc::IceServer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::keypackage::KeyPackageData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.key_package_base64.into_into_dart().into_dart(),
            self.tags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::keypackage::KeyPackageData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::keypackage::KeyPackageData>
    for crate::api::keypackage::KeyPackageData
{
    fn into_into_dart(self) -> crate::api::keypackage::KeyPackageData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media::MediaReferenceInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.original_hash_hex.into_into_dart().into_dart(),
            self.mime_type.into_into_dart().into_dart(),
            self.filename.into_into_dart().into_dart(),
            self.dimensions.into_into_dart().into_dart(),
            self.scheme_version.into_into_dart().into_dart(),
            self.nonce_hex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::MediaReferenceInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media::MediaReferenceInfo>
    for crate::api::media::MediaReferenceInfo
{
    fn into_into_dart(self) -> crate::api::media::MediaReferenceInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::group::MemberInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.pubkey_hex.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::group::MemberInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::group::MemberInfo>
    for crate::api::group::MemberInfo
{
    fn into_into_dart(self) -> crate::api::group::MemberInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::PeerConnectionState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::New => 0.into_dart(),
            Self::Checking => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::Disconnected => 3.into_dart(),
            Self::Failed => 4.into_dart(),
            Self::Closed => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::PeerConnectionState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::PeerConnectionState>
    for crate::api::call_webrtc::PeerConnectionState
{
    fn into_into_dart(self) -> crate::api::call_webrtc::PeerConnectionState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::PeerEntry {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.participant_pubkey_hex.into_into_dart().into_dart(),
            self.connection_state.into_into_dart().into_dart(),
            self.call_id.into_into_dart().into_dart(),
            self.has_audio_track.into_into_dart().into_dart(),
            self.has_video_track.into_into_dart().into_dart(),
            self.is_remote_muted.into_into_dart().into_dart(),
            self.is_remote_video_enabled.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.updated_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::PeerEntry
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::PeerEntry>
    for crate::api::call_webrtc::PeerEntry
{
    fn into_into_dart(self) -> crate::api::call_webrtc::PeerEntry {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::PeerStats {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.participant_pubkey_hex.into_into_dart().into_dart(),
            self.rtt_ms.into_into_dart().into_dart(),
            self.packet_loss_percent.into_into_dart().into_dart(),
            self.outgoing_bitrate_kbps.into_into_dart().into_dart(),
            self.incoming_bitrate_kbps.into_into_dart().into_dart(),
            self.quality_score.into_into_dart().into_dart(),
            self.timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::PeerStats
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::PeerStats>
    for crate::api::call_webrtc::PeerStats
{
    fn into_into_dart(self) -> crate::api::call_webrtc::PeerStats {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::message::ProcessMessageResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.result_type.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
            self.mls_group_id_hex.into_into_dart().into_dart(),
            self.evolution_event_json.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::message::ProcessMessageResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::message::ProcessMessageResult>
    for crate::api::message::ProcessMessageResult
{
    fn into_into_dart(self) -> crate::api::message::ProcessMessageResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::identity::ProfileData {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.display_name.into_into_dart().into_dart(),
            self.about.into_into_dart().into_dart(),
            self.picture.into_into_dart().into_dart(),
            self.nip05.into_into_dart().into_dart(),
            self.lud16.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::identity::ProfileData
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::identity::ProfileData>
    for crate::api::identity::ProfileData
{
    fn into_into_dart(self) -> crate::api::identity::ProfileData {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::QualityRecommendation {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.preset.into_into_dart().into_dart(),
            self.audio_mode.into_into_dart().into_dart(),
            self.use_simulcast.into_into_dart().into_dart(),
            self.reason.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::QualityRecommendation
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::QualityRecommendation>
    for crate::api::call_quality::QualityRecommendation
{
    fn into_into_dart(self) -> crate::api::call_quality::QualityRecommendation {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::QualityScore {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.score.into_into_dart().into_dart(),
            self.label.into_into_dart().into_dart(),
            self.rtt_score.into_into_dart().into_dart(),
            self.jitter_score.into_into_dart().into_dart(),
            self.loss_score.into_into_dart().into_dart(),
            self.bitrate_score.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::QualityScore
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::QualityScore>
    for crate::api::call_quality::QualityScore
{
    fn into_into_dart(self) -> crate::api::call_quality::QualityScore {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::relay::RelayInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.connected.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::relay::RelayInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::relay::RelayInfo>
    for crate::api::relay::RelayInfo
{
    fn into_into_dart(self) -> crate::api::relay::RelayInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::SdpInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sdp_type.into_into_dart().into_dart(),
            self.has_audio.into_into_dart().into_dart(),
            self.has_video.into_into_dart().into_dart(),
            self.media_count.into_into_dart().into_dart(),
            self.ice_ufrag.into_into_dart().into_dart(),
            self.codecs.into_into_dart().into_dart(),
            self.is_valid.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::SdpInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::SdpInfo>
    for crate::api::call_webrtc::SdpInfo
{
    fn into_into_dart(self) -> crate::api::call_webrtc::SdpInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::SfuConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.server_url.into_into_dart().into_dart(),
            self.room_name.into_into_dart().into_dart(),
            self.token.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::SfuConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::SfuConfig>
    for crate::api::call_webrtc::SfuConfig
{
    fn into_into_dart(self) -> crate::api::call_webrtc::SfuConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::SimulcastConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.enabled.into_into_dart().into_dart(),
            self.layers.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::SimulcastConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::SimulcastConfig>
    for crate::api::call_quality::SimulcastConfig
{
    fn into_into_dart(self) -> crate::api::call_quality::SimulcastConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::SimulcastLayer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rid.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.frame_rate.into_into_dart().into_dart(),
            self.max_bitrate_bps.into_into_dart().into_dart(),
            self.scale_resolution_down_by.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::SimulcastLayer
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::SimulcastLayer>
    for crate::api::call_quality::SimulcastLayer
{
    fn into_into_dart(self) -> crate::api::call_quality::SimulcastLayer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::group::UpdateGroupResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.evolution_event_json.into_into_dart().into_dart(),
            self.welcome_rumors_json.into_into_dart().into_dart(),
            self.mls_group_id_hex.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::group::UpdateGroupResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::group::UpdateGroupResult>
    for crate::api::group::UpdateGroupResult
{
    fn into_into_dart(self) -> crate::api::group::UpdateGroupResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::media::UploadMediaResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.url.into_into_dart().into_dart(),
            self.imeta_tag_values.into_into_dart().into_dart(),
            self.reference.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::media::UploadMediaResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::media::UploadMediaResult>
    for crate::api::media::UploadMediaResult
{
    fn into_into_dart(self) -> crate::api::media::UploadMediaResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::VideoConstraints {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.frame_rate.into_into_dart().into_dart(),
            self.max_bitrate_bps.into_into_dart().into_dart(),
            self.min_bitrate_bps.into_into_dart().into_dart(),
            self.preferred_codec.into_into_dart().into_dart(),
            self.hardware_acceleration.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::VideoConstraints
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::VideoConstraints>
    for crate::api::call_quality::VideoConstraints
{
    fn into_into_dart(self) -> crate::api::call_quality::VideoConstraints {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_quality::VideoQualityPreset {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Low => 0.into_dart(),
            Self::Medium => 1.into_dart(),
            Self::High => 2.into_dart(),
            Self::Hd => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_quality::VideoQualityPreset
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_quality::VideoQualityPreset>
    for crate::api::call_quality::VideoQualityPreset
{
    fn into_into_dart(self) -> crate::api::call_quality::VideoQualityPreset {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::call_webrtc::WebRtcConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ice_servers.into_into_dart().into_dart(),
            self.sdp_semantics.into_into_dart().into_dart(),
            self.bundle_policy.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::call_webrtc::WebRtcConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::call_webrtc::WebRtcConfig>
    for crate::api::call_webrtc::WebRtcConfig
{
    fn into_into_dart(self) -> crate::api::call_webrtc::WebRtcConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::invite::WelcomeInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.welcome_event_id.into_into_dart().into_dart(),
            self.mls_group_id_hex.into_into_dart().into_dart(),
            self.nostr_group_id_hex.into_into_dart().into_dart(),
            self.group_name.into_into_dart().into_dart(),
            self.group_description.into_into_dart().into_dart(),
            self.welcomer_pubkey_hex.into_into_dart().into_dart(),
            self.member_count.into_into_dart().into_dart(),
            self.state.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::invite::WelcomeInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::invite::WelcomeInfo>
    for crate::api::invite::WelcomeInfo
{
    fn into_into_dart(self) -> crate::api::invite::WelcomeInfo {
        self
    }
}

impl SseEncode for BurrowState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Client {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for Keys {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for MDK<MdkMemoryStorage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK<MdkMemoryStorage>>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK<MdkMemoryStorage>>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::account::AccountInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pubkey_hex, serializer);
        <String>::sse_encode(self.npub, serializer);
    }
}

impl SseEncode for crate::api::call_quality::AdaptiveBitrateConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.degradation_threshold_bps, serializer);
        <u32>::sse_encode(self.recovery_threshold_bps, serializer);
        <u32>::sse_encode(self.hysteresis_ms, serializer);
        <Vec<String>>::sse_encode(self.quality_steps, serializer);
        <f64>::sse_encode(self.max_tolerable_loss_percent, serializer);
        <f64>::sse_encode(self.max_tolerable_rtt_ms, serializer);
    }
}

impl SseEncode for crate::api::call_quality::AudioConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.sample_rate, serializer);
        <u32>::sse_encode(self.channel_count, serializer);
        <bool>::sse_encode(self.echo_cancellation, serializer);
        <bool>::sse_encode(self.noise_suppression, serializer);
        <bool>::sse_encode(self.auto_gain_control, serializer);
        <u32>::sse_encode(self.bitrate_bps, serializer);
        <bool>::sse_encode(self.dtx_enabled, serializer);
        <bool>::sse_encode(self.fec_enabled, serializer);
        <u32>::sse_encode(self.ptime_ms, serializer);
    }
}

impl SseEncode for crate::api::call_quality::AudioMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::call_quality::AudioMode::Voice => 0,
                crate::api::call_quality::AudioMode::Music => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::error::BurrowError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for crate::api::call_session::CallDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::call_session::CallDirection::Outgoing => 0,
                crate::api::call_session::CallDirection::Incoming => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::call_session::CallSession {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.call_id, serializer);
        <crate::api::call_session::CallState>::sse_encode(self.state, serializer);
        <crate::api::call_session::CallType>::sse_encode(self.call_type, serializer);
        <crate::api::call_session::CallDirection>::sse_encode(self.direction, serializer);
        <Vec<String>>::sse_encode(self.participants, serializer);
        <String>::sse_encode(self.local_pubkey_hex, serializer);
        <String>::sse_encode(self.remote_pubkey_hex, serializer);
        <Option<String>>::sse_encode(self.group_id_hex, serializer);
        <u64>::sse_encode(self.created_at, serializer);
        <Option<u64>>::sse_encode(self.started_at, serializer);
        <Option<u64>>::sse_encode(self.ended_at, serializer);
        <bool>::sse_encode(self.is_muted, serializer);
        <bool>::sse_encode(self.is_video_enabled, serializer);
    }
}

impl SseEncode for crate::api::call_signaling::CallSignalingEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.kind, serializer);
        <String>::sse_encode(self.sender_pubkey_hex, serializer);
        <String>::sse_encode(self.call_id, serializer);
        <Option<String>>::sse_encode(self.call_type, serializer);
        <String>::sse_encode(self.content, serializer);
        <u64>::sse_encode(self.created_at, serializer);
    }
}

impl SseEncode for crate::api::call_session::CallState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::call_session::CallState::Idle => 0,
                crate::api::call_session::CallState::Initiating => 1,
                crate::api::call_session::CallState::Ringing => 2,
                crate::api::call_session::CallState::Connecting => 3,
                crate::api::call_session::CallState::Active => 4,
                crate::api::call_session::CallState::Ending => 5,
                crate::api::call_session::CallState::Failed => 6,
                crate::api::call_session::CallState::Rejected => 7,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::call_session::CallType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::call_session::CallType::Audio => 0,
                crate::api::call_session::CallType::Video => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::call_quality::CodecPreferences {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.audio_codecs, serializer);
        <Vec<String>>::sse_encode(self.video_codecs, serializer);
    }
}

impl SseEncode for crate::api::group::CreateGroupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::group::GroupInfo>::sse_encode(self.group, serializer);
        <Vec<String>>::sse_encode(self.welcome_rumors_json, serializer);
        <String>::sse_encode(self.mls_group_id_hex, serializer);
    }
}

impl SseEncode for crate::api::media::EncryptedFileResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.encrypted_data, serializer);
        <String>::sse_encode(self.original_hash_hex, serializer);
        <String>::sse_encode(self.encrypted_hash_hex, serializer);
        <String>::sse_encode(self.mime_type, serializer);
        <String>::sse_encode(self.filename, serializer);
        <u64>::sse_encode(self.original_size, serializer);
        <u64>::sse_encode(self.encrypted_size, serializer);
        <Option<String>>::sse_encode(self.dimensions, serializer);
        <Option<String>>::sse_encode(self.blurhash, serializer);
        <String>::sse_encode(self.nonce_hex, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::group::GroupInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.mls_group_id_hex, serializer);
        <String>::sse_encode(self.nostr_group_id_hex, serializer);
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.description, serializer);
        <Vec<String>>::sse_encode(self.admin_pubkeys, serializer);
        <u64>::sse_encode(self.epoch, serializer);
        <String>::sse_encode(self.state, serializer);
    }
}

impl SseEncode for crate::api::message::GroupMessage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.event_id_hex, serializer);
        <String>::sse_encode(self.author_pubkey_hex, serializer);
        <String>::sse_encode(self.content, serializer);
        <u64>::sse_encode(self.created_at, serializer);
        <String>::sse_encode(self.mls_group_id_hex, serializer);
        <u64>::sse_encode(self.kind, serializer);
        <Vec<Vec<String>>>::sse_encode(self.tags, serializer);
        <String>::sse_encode(self.wrapper_event_id_hex, serializer);
        <u64>::sse_encode(self.epoch, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::call_webrtc::IceServer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.urls, serializer);
        <Option<String>>::sse_encode(self.username, serializer);
        <Option<String>>::sse_encode(self.credential, serializer);
    }
}

impl SseEncode for crate::api::keypackage::KeyPackageData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.key_package_base64, serializer);
        <Vec<Vec<String>>>::sse_encode(self.tags, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::call_session::CallSession> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::call_session::CallSession>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::group::GroupInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::group::GroupInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::message::GroupMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::message::GroupMessage>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::call_webrtc::IceServer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::call_webrtc::IceServer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<String>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<String>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::group::MemberInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::group::MemberInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::call_webrtc::PeerEntry> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::call_webrtc::PeerEntry>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::relay::RelayInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::relay::RelayInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::call_quality::SimulcastLayer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::call_quality::SimulcastLayer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::invite::WelcomeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::invite::WelcomeInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::media::MediaReferenceInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <String>::sse_encode(self.original_hash_hex, serializer);
        <String>::sse_encode(self.mime_type, serializer);
        <String>::sse_encode(self.filename, serializer);
        <Option<String>>::sse_encode(self.dimensions, serializer);
        <String>::sse_encode(self.scheme_version, serializer);
        <String>::sse_encode(self.nonce_hex, serializer);
    }
}

impl SseEncode for crate::api::group::MemberInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.pubkey_hex, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::call_session::CallSession> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::call_session::CallSession>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::call_signaling::CallSignalingEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::call_signaling::CallSignalingEvent>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::message::GroupMessage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::message::GroupMessage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::call_webrtc::PeerStats> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::call_webrtc::PeerStats>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::call_webrtc::PeerConnectionState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::call_webrtc::PeerConnectionState::New => 0,
                crate::api::call_webrtc::PeerConnectionState::Checking => 1,
                crate::api::call_webrtc::PeerConnectionState::Connected => 2,
                crate::api::call_webrtc::PeerConnectionState::Disconnected => 3,
                crate::api::call_webrtc::PeerConnectionState::Failed => 4,
                crate::api::call_webrtc::PeerConnectionState::Closed => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::call_webrtc::PeerEntry {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.participant_pubkey_hex, serializer);
        <crate::api::call_webrtc::PeerConnectionState>::sse_encode(
            self.connection_state,
            serializer,
        );
        <String>::sse_encode(self.call_id, serializer);
        <bool>::sse_encode(self.has_audio_track, serializer);
        <bool>::sse_encode(self.has_video_track, serializer);
        <bool>::sse_encode(self.is_remote_muted, serializer);
        <bool>::sse_encode(self.is_remote_video_enabled, serializer);
        <u64>::sse_encode(self.created_at, serializer);
        <u64>::sse_encode(self.updated_at, serializer);
    }
}

impl SseEncode for crate::api::call_webrtc::PeerStats {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.participant_pubkey_hex, serializer);
        <Option<f64>>::sse_encode(self.rtt_ms, serializer);
        <Option<f64>>::sse_encode(self.packet_loss_percent, serializer);
        <Option<f64>>::sse_encode(self.outgoing_bitrate_kbps, serializer);
        <Option<f64>>::sse_encode(self.incoming_bitrate_kbps, serializer);
        <Option<f64>>::sse_encode(self.quality_score, serializer);
        <u64>::sse_encode(self.timestamp, serializer);
    }
}

impl SseEncode for crate::api::message::ProcessMessageResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.result_type, serializer);
        <Option<crate::api::message::GroupMessage>>::sse_encode(self.message, serializer);
        <String>::sse_encode(self.mls_group_id_hex, serializer);
        <Option<String>>::sse_encode(self.evolution_event_json, serializer);
    }
}

impl SseEncode for crate::api::identity::ProfileData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.display_name, serializer);
        <Option<String>>::sse_encode(self.about, serializer);
        <Option<String>>::sse_encode(self.picture, serializer);
        <Option<String>>::sse_encode(self.nip05, serializer);
        <Option<String>>::sse_encode(self.lud16, serializer);
    }
}

impl SseEncode for crate::api::call_quality::QualityRecommendation {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.preset, serializer);
        <String>::sse_encode(self.audio_mode, serializer);
        <bool>::sse_encode(self.use_simulcast, serializer);
        <String>::sse_encode(self.reason, serializer);
    }
}

impl SseEncode for crate::api::call_quality::QualityScore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.score, serializer);
        <String>::sse_encode(self.label, serializer);
        <f64>::sse_encode(self.rtt_score, serializer);
        <f64>::sse_encode(self.jitter_score, serializer);
        <f64>::sse_encode(self.loss_score, serializer);
        <f64>::sse_encode(self.bitrate_score, serializer);
    }
}

impl SseEncode for crate::api::relay::RelayInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <bool>::sse_encode(self.connected, serializer);
    }
}

impl SseEncode for crate::api::call_webrtc::SdpInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sdp_type, serializer);
        <bool>::sse_encode(self.has_audio, serializer);
        <bool>::sse_encode(self.has_video, serializer);
        <u32>::sse_encode(self.media_count, serializer);
        <Option<String>>::sse_encode(self.ice_ufrag, serializer);
        <Vec<String>>::sse_encode(self.codecs, serializer);
        <bool>::sse_encode(self.is_valid, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::api::call_webrtc::SfuConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.server_url, serializer);
        <String>::sse_encode(self.room_name, serializer);
        <String>::sse_encode(self.token, serializer);
    }
}

impl SseEncode for crate::api::call_quality::SimulcastConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.enabled, serializer);
        <Vec<crate::api::call_quality::SimulcastLayer>>::sse_encode(self.layers, serializer);
    }
}

impl SseEncode for crate::api::call_quality::SimulcastLayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.rid, serializer);
        <u32>::sse_encode(self.width, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.frame_rate, serializer);
        <u32>::sse_encode(self.max_bitrate_bps, serializer);
        <f64>::sse_encode(self.scale_resolution_down_by, serializer);
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::group::UpdateGroupResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.evolution_event_json, serializer);
        <Vec<String>>::sse_encode(self.welcome_rumors_json, serializer);
        <String>::sse_encode(self.mls_group_id_hex, serializer);
    }
}

impl SseEncode for crate::api::media::UploadMediaResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.url, serializer);
        <Vec<String>>::sse_encode(self.imeta_tag_values, serializer);
        <crate::api::media::MediaReferenceInfo>::sse_encode(self.reference, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::call_quality::VideoConstraints {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.width, serializer);
        <u32>::sse_encode(self.height, serializer);
        <u32>::sse_encode(self.frame_rate, serializer);
        <u32>::sse_encode(self.max_bitrate_bps, serializer);
        <u32>::sse_encode(self.min_bitrate_bps, serializer);
        <String>::sse_encode(self.preferred_codec, serializer);
        <bool>::sse_encode(self.hardware_acceleration, serializer);
    }
}

impl SseEncode for crate::api::call_quality::VideoQualityPreset {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::call_quality::VideoQualityPreset::Low => 0,
                crate::api::call_quality::VideoQualityPreset::Medium => 1,
                crate::api::call_quality::VideoQualityPreset::High => 2,
                crate::api::call_quality::VideoQualityPreset::Hd => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::call_webrtc::WebRtcConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::call_webrtc::IceServer>>::sse_encode(self.ice_servers, serializer);
        <String>::sse_encode(self.sdp_semantics, serializer);
        <String>::sse_encode(self.bundle_policy, serializer);
    }
}

impl SseEncode for crate::api::invite::WelcomeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.welcome_event_id, serializer);
        <String>::sse_encode(self.mls_group_id_hex, serializer);
        <String>::sse_encode(self.nostr_group_id_hex, serializer);
        <String>::sse_encode(self.group_name, serializer);
        <String>::sse_encode(self.group_description, serializer);
        <String>::sse_encode(self.welcomer_pubkey_hex, serializer);
        <u32>::sse_encode(self.member_count, serializer);
        <String>::sse_encode(self.state, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::state::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBurrowState(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBurrowState(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeys(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeys(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMDKMdkMemoryStorage(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK < MdkMemoryStorage >>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_burrow_app_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMDKMdkMemoryStorage(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK < MdkMemoryStorage >>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::state::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBurrowState(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBurrowState(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BurrowState>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeys(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerKeys(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Keys>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMDKMdkMemoryStorage(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK < MdkMemoryStorage >>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMDKMdkMemoryStorage(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MDK < MdkMemoryStorage >>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
