// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `build_media_reference`, `parse_blossom_url`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// Encrypt a file for a group using MIP-04 v2.
///
/// Derives a file-specific key from the group's current MLS exporter secret,
/// generates a random nonce, and encrypts with ChaCha20-Poly1305 + AAD.
Future<EncryptedFileResult> encryptFile({
  required String mlsGroupIdHex,
  required List<int> fileData,
  required String mimeType,
  required String filename,
}) => RustLib.instance.api.crateApiMediaEncryptFile(
  mlsGroupIdHex: mlsGroupIdHex,
  fileData: fileData,
  mimeType: mimeType,
  filename: filename,
);

/// Decrypt an encrypted file received from a group.
///
/// Uses the imeta tag fields to reconstruct AAD and derive the correct key
/// from the group's exporter secret (with epoch fallback).
Future<Uint8List> decryptFile({
  required String mlsGroupIdHex,
  required List<int> encryptedData,
  required String url,
  required String mimeType,
  required String filename,
  required String originalHashHex,
  required String nonceHex,
  required String schemeVersion,
  String? dimensions,
}) => RustLib.instance.api.crateApiMediaDecryptFile(
  mlsGroupIdHex: mlsGroupIdHex,
  encryptedData: encryptedData,
  url: url,
  mimeType: mimeType,
  filename: filename,
  originalHashHex: originalHashHex,
  nonceHex: nonceHex,
  schemeVersion: schemeVersion,
  dimensions: dimensions,
);

/// Upload encrypted media to a Blossom server and return imeta tag data.
///
/// 1. Encrypts the file via MIP-04 v2.
/// 2. Uploads the ciphertext to `blossom_server_url` using HTTP PUT.
/// 3. Constructs the imeta tag from the upload result + returned URL.
Future<UploadMediaResult> uploadMedia({
  required String mlsGroupIdHex,
  required List<int> fileData,
  required String mimeType,
  required String filename,
  required String blossomServerUrl,
}) => RustLib.instance.api.crateApiMediaUploadMedia(
  mlsGroupIdHex: mlsGroupIdHex,
  fileData: fileData,
  mimeType: mimeType,
  filename: filename,
  blossomServerUrl: blossomServerUrl,
);

/// Download encrypted media from a Blossom URL and decrypt it.
///
/// 1. Fetches the ciphertext from `url`.
/// 2. Decrypts using the group's exporter secret + imeta metadata.
/// 3. Returns the plaintext bytes.
Future<Uint8List> downloadMedia({
  required String mlsGroupIdHex,
  required String url,
  required String mimeType,
  required String filename,
  required String originalHashHex,
  required String nonceHex,
  required String schemeVersion,
  String? dimensions,
}) => RustLib.instance.api.crateApiMediaDownloadMedia(
  mlsGroupIdHex: mlsGroupIdHex,
  url: url,
  mimeType: mimeType,
  filename: filename,
  originalHashHex: originalHashHex,
  nonceHex: nonceHex,
  schemeVersion: schemeVersion,
  dimensions: dimensions,
);

/// Build an imeta tag value array from media metadata.
///
/// Returns a flat `Vec<String>` of "key value" pairs suitable for inclusion
/// in a Nostr event tag: `["imeta", "url ...", "m ...", ...]`.
Future<List<String>> buildImetaTag({
  required String url,
  required String mimeType,
  required String filename,
  required String originalHashHex,
  required String nonceHex,
  String? dimensions,
  String? blurhash,
}) => RustLib.instance.api.crateApiMediaBuildImetaTag(
  url: url,
  mimeType: mimeType,
  filename: filename,
  originalHashHex: originalHashHex,
  nonceHex: nonceHex,
  dimensions: dimensions,
  blurhash: blurhash,
);

/// Parse an imeta tag (as a flat string array) into a `MediaReferenceInfo`.
///
/// Input: the tag values *after* the "imeta" prefix, e.g.
/// `["url https://...", "m image/jpeg", "filename photo.jpg", "x abc...", "n def...", "v mip04-v2"]`
Future<MediaReferenceInfo> parseImetaTag({required List<String> tagValues}) =>
    RustLib.instance.api.crateApiMediaParseImetaTag(tagValues: tagValues);

/// Metadata about an encrypted file, ready for upload or imeta tag creation.
class EncryptedFileResult {
  /// Encrypted bytes (ciphertext + Poly1305 tag).
  final Uint8List encryptedData;

  /// SHA-256 of the *original* plaintext file (hex).
  final String originalHashHex;

  /// SHA-256 of the encrypted data (hex).
  final String encryptedHashHex;

  /// Canonical MIME type.
  final String mimeType;

  /// Original filename.
  final String filename;

  /// Original file size in bytes.
  final BigInt originalSize;

  /// Encrypted file size in bytes.
  final BigInt encryptedSize;

  /// Image/video dimensions ("widthxheight") if applicable.
  final String? dimensions;

  /// Blurhash string for progressive image loading.
  final String? blurhash;

  /// Encryption nonce (hex, 24 chars / 12 bytes).
  final String nonceHex;

  const EncryptedFileResult({
    required this.encryptedData,
    required this.originalHashHex,
    required this.encryptedHashHex,
    required this.mimeType,
    required this.filename,
    required this.originalSize,
    required this.encryptedSize,
    this.dimensions,
    this.blurhash,
    required this.nonceHex,
  });

  @override
  int get hashCode =>
      encryptedData.hashCode ^
      originalHashHex.hashCode ^
      encryptedHashHex.hashCode ^
      mimeType.hashCode ^
      filename.hashCode ^
      originalSize.hashCode ^
      encryptedSize.hashCode ^
      dimensions.hashCode ^
      blurhash.hashCode ^
      nonceHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EncryptedFileResult &&
          runtimeType == other.runtimeType &&
          encryptedData == other.encryptedData &&
          originalHashHex == other.originalHashHex &&
          encryptedHashHex == other.encryptedHashHex &&
          mimeType == other.mimeType &&
          filename == other.filename &&
          originalSize == other.originalSize &&
          encryptedSize == other.encryptedSize &&
          dimensions == other.dimensions &&
          blurhash == other.blurhash &&
          nonceHex == other.nonceHex;
}

/// Parsed imeta tag fields for a received encrypted media reference.
class MediaReferenceInfo {
  /// Blossom storage URL.
  final String url;

  /// SHA-256 of the original file (hex).
  final String originalHashHex;

  /// MIME type.
  final String mimeType;

  /// Original filename.
  final String filename;

  /// Dimensions ("widthxheight") if present.
  final String? dimensions;

  /// Encryption scheme version (e.g. "mip04-v2").
  final String schemeVersion;

  /// Nonce (hex, 24 chars).
  final String nonceHex;

  const MediaReferenceInfo({
    required this.url,
    required this.originalHashHex,
    required this.mimeType,
    required this.filename,
    this.dimensions,
    required this.schemeVersion,
    required this.nonceHex,
  });

  @override
  int get hashCode =>
      url.hashCode ^
      originalHashHex.hashCode ^
      mimeType.hashCode ^
      filename.hashCode ^
      dimensions.hashCode ^
      schemeVersion.hashCode ^
      nonceHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaReferenceInfo &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          originalHashHex == other.originalHashHex &&
          mimeType == other.mimeType &&
          filename == other.filename &&
          dimensions == other.dimensions &&
          schemeVersion == other.schemeVersion &&
          nonceHex == other.nonceHex;
}

/// Result of uploading encrypted media to a Blossom server.
class UploadMediaResult {
  /// The Blossom URL where the encrypted file was stored.
  final String url;

  /// Serialised imeta tag values (flat string array) for inclusion in a message.
  final List<String> imetaTagValues;

  /// The parsed media reference info.
  final MediaReferenceInfo reference;

  const UploadMediaResult({
    required this.url,
    required this.imetaTagValues,
    required this.reference,
  });

  @override
  int get hashCode =>
      url.hashCode ^ imetaTagValues.hashCode ^ reference.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UploadMediaResult &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          imetaTagValues == other.imetaTagValues &&
          reference == other.reference;
}
