// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `score_bitrate`, `score_jitter`, `score_loss`, `score_rtt`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Get audio constraints for the given mode.
///
/// Voice mode: mono, 32kbps Opus, full processing pipeline, DTX + FEC.
/// Music mode: stereo, 96kbps Opus, no processing, no DTX.
Future<AudioConstraints> getAudioConstraints({required AudioMode mode}) =>
    RustLib.instance.api.crateApiCallQualityGetAudioConstraints(mode: mode);

/// Get video constraints for a given quality preset.
///
/// Presets are tuned for mobile: moderate resolutions, conservative bitrates,
/// hardware acceleration preferred for battery life.
Future<VideoConstraints> getVideoConstraints({
  required VideoQualityPreset preset,
}) =>
    RustLib.instance.api.crateApiCallQualityGetVideoConstraints(preset: preset);

/// Get default adaptive bitrate configuration.
///
/// Tuned for mobile: conservative thresholds, 3-second hysteresis to prevent
/// rapid quality oscillation on flaky cellular connections.
Future<AdaptiveBitrateConfig> getAdaptiveBitrateConfig() =>
    RustLib.instance.api.crateApiCallQualityGetAdaptiveBitrateConfig();

/// Calculate a composite quality score from network metrics.
///
/// Weights: RTT 25%, jitter 20%, packet loss 35%, bitrate adequacy 20%.
/// Packet loss is weighted highest because it has the most audible impact.
Future<QualityScore> calculateQualityScore({
  required double rttMs,
  required double jitterMs,
  required double packetLossPercent,
  required double bitrateKbps,
  required bool isVideo,
}) => RustLib.instance.api.crateApiCallQualityCalculateQualityScore(
  rttMs: rttMs,
  jitterMs: jitterMs,
  packetLossPercent: packetLossPercent,
  bitrateKbps: bitrateKbps,
  isVideo: isVideo,
);

/// Get simulcast configuration for SFU group calls.
///
/// Three layers: low (180p), medium (360p), high (720p).
/// The SFU selects which layer to forward based on each receiver's bandwidth.
Future<SimulcastConfig> getSimulcastConfig() =>
    RustLib.instance.api.crateApiCallQualityGetSimulcastConfig();

/// Recommend a quality preset based on network conditions and call context.
///
/// Takes into account estimated bandwidth, current quality score, and
/// participant count (more participants = lower per-user bandwidth).
Future<QualityRecommendation> recommendQualityPreset({
  required double qualityScore,
  required double estimatedBandwidthKbps,
  required int participantCount,
}) => RustLib.instance.api.crateApiCallQualityRecommendQualityPreset(
  qualityScore: qualityScore,
  estimatedBandwidthKbps: estimatedBandwidthKbps,
  participantCount: participantCount,
);

/// Get codec preferences for SDP munging.
///
/// Audio: Opus is the only real choice for WebRTC (mandatory-to-implement).
/// Video: Prefer H264 (hardware acceleration on most mobile) > VP8 (universal fallback) > VP9.
Future<CodecPreferences> getCodecPreferences() =>
    RustLib.instance.api.crateApiCallQualityGetCodecPreferences();

/// Adaptive bitrate configuration for bandwidth estimation and quality stepping.
class AdaptiveBitrateConfig {
  /// If estimated bandwidth drops below this (bps), degrade quality.
  final int degradationThresholdBps;

  /// If estimated bandwidth rises above this (bps), try to recover quality.
  final int recoveryThresholdBps;

  /// Minimum time (ms) between quality changes to avoid oscillation.
  final int hysteresisMs;

  /// Ordered list of video presets from worst to best for stepping.
  final List<String> qualitySteps;

  /// Packet loss % above which we force degradation regardless of bandwidth.
  final double maxTolerableLossPercent;

  /// RTT (ms) above which we force degradation.
  final double maxTolerableRttMs;

  const AdaptiveBitrateConfig({
    required this.degradationThresholdBps,
    required this.recoveryThresholdBps,
    required this.hysteresisMs,
    required this.qualitySteps,
    required this.maxTolerableLossPercent,
    required this.maxTolerableRttMs,
  });

  @override
  int get hashCode =>
      degradationThresholdBps.hashCode ^
      recoveryThresholdBps.hashCode ^
      hysteresisMs.hashCode ^
      qualitySteps.hashCode ^
      maxTolerableLossPercent.hashCode ^
      maxTolerableRttMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AdaptiveBitrateConfig &&
          runtimeType == other.runtimeType &&
          degradationThresholdBps == other.degradationThresholdBps &&
          recoveryThresholdBps == other.recoveryThresholdBps &&
          hysteresisMs == other.hysteresisMs &&
          qualitySteps == other.qualitySteps &&
          maxTolerableLossPercent == other.maxTolerableLossPercent &&
          maxTolerableRttMs == other.maxTolerableRttMs;
}

/// Audio codec and processing configuration.
class AudioConstraints {
  /// Sample rate in Hz (48000 for Opus).
  final int sampleRate;

  /// Number of channels: 1 = mono (voice), 2 = stereo (music).
  final int channelCount;

  /// Enable acoustic echo cancellation.
  final bool echoCancellation;

  /// Enable noise suppression.
  final bool noiseSuppression;

  /// Enable automatic gain control.
  final bool autoGainControl;

  /// Target bitrate in bps. Opus voice: 24000-32000, music: 64000-128000.
  final int bitrateBps;

  /// Enable discontinuous transmission (saves bandwidth during silence).
  final bool dtxEnabled;

  /// Opus FEC for packet loss resilience.
  final bool fecEnabled;

  /// Packet time in ms (20 = default, 40/60 = lower overhead on constrained links).
  final int ptimeMs;

  const AudioConstraints({
    required this.sampleRate,
    required this.channelCount,
    required this.echoCancellation,
    required this.noiseSuppression,
    required this.autoGainControl,
    required this.bitrateBps,
    required this.dtxEnabled,
    required this.fecEnabled,
    required this.ptimeMs,
  });

  @override
  int get hashCode =>
      sampleRate.hashCode ^
      channelCount.hashCode ^
      echoCancellation.hashCode ^
      noiseSuppression.hashCode ^
      autoGainControl.hashCode ^
      bitrateBps.hashCode ^
      dtxEnabled.hashCode ^
      fecEnabled.hashCode ^
      ptimeMs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioConstraints &&
          runtimeType == other.runtimeType &&
          sampleRate == other.sampleRate &&
          channelCount == other.channelCount &&
          echoCancellation == other.echoCancellation &&
          noiseSuppression == other.noiseSuppression &&
          autoGainControl == other.autoGainControl &&
          bitrateBps == other.bitrateBps &&
          dtxEnabled == other.dtxEnabled &&
          fecEnabled == other.fecEnabled &&
          ptimeMs == other.ptimeMs;
}

/// Audio mode selection.
enum AudioMode {
  /// Optimized for speech: mono, noise suppression, echo cancellation.
  voice,

  /// Optimized for music sharing: stereo, no processing, higher bitrate.
  music,
}

/// Preferred codec ordering for SDP manipulation.
class CodecPreferences {
  /// Ordered audio codec preferences (first = most preferred).
  final List<String> audioCodecs;

  /// Ordered video codec preferences.
  final List<String> videoCodecs;

  const CodecPreferences({
    required this.audioCodecs,
    required this.videoCodecs,
  });

  @override
  int get hashCode => audioCodecs.hashCode ^ videoCodecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CodecPreferences &&
          runtimeType == other.runtimeType &&
          audioCodecs == other.audioCodecs &&
          videoCodecs == other.videoCodecs;
}

/// Recommended quality preset with reasoning.
class QualityRecommendation {
  /// Recommended video preset name: "low", "medium", "high", "hd".
  final String preset;

  /// Recommended audio mode: "voice" or "music".
  final String audioMode;

  /// Whether simulcast should be enabled.
  final bool useSimulcast;

  /// Human-readable reason for the recommendation.
  final String reason;

  const QualityRecommendation({
    required this.preset,
    required this.audioMode,
    required this.useSimulcast,
    required this.reason,
  });

  @override
  int get hashCode =>
      preset.hashCode ^
      audioMode.hashCode ^
      useSimulcast.hashCode ^
      reason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QualityRecommendation &&
          runtimeType == other.runtimeType &&
          preset == other.preset &&
          audioMode == other.audioMode &&
          useSimulcast == other.useSimulcast &&
          reason == other.reason;
}

/// Composite quality score result.
class QualityScore {
  /// Overall score 0.0 (unusable) to 1.0 (excellent).
  final double score;

  /// Human-readable label: "excellent", "good", "fair", "poor", "unusable".
  final String label;

  /// Per-metric breakdown.
  final double rttScore;
  final double jitterScore;
  final double lossScore;
  final double bitrateScore;

  const QualityScore({
    required this.score,
    required this.label,
    required this.rttScore,
    required this.jitterScore,
    required this.lossScore,
    required this.bitrateScore,
  });

  @override
  int get hashCode =>
      score.hashCode ^
      label.hashCode ^
      rttScore.hashCode ^
      jitterScore.hashCode ^
      lossScore.hashCode ^
      bitrateScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QualityScore &&
          runtimeType == other.runtimeType &&
          score == other.score &&
          label == other.label &&
          rttScore == other.rttScore &&
          jitterScore == other.jitterScore &&
          lossScore == other.lossScore &&
          bitrateScore == other.bitrateScore;
}

/// Full simulcast configuration for SFU group calls.
class SimulcastConfig {
  /// Whether simulcast is enabled.
  final bool enabled;

  /// Ordered layers from lowest to highest quality.
  final List<SimulcastLayer> layers;

  const SimulcastConfig({required this.enabled, required this.layers});

  @override
  int get hashCode => enabled.hashCode ^ layers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SimulcastConfig &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          layers == other.layers;
}

/// A single simulcast layer.
class SimulcastLayer {
  /// Layer identifier: "low", "medium", "high".
  final String rid;
  final int width;
  final int height;
  final int frameRate;
  final int maxBitrateBps;

  /// Scale-down factor relative to capture resolution (e.g. 4.0 = 1/4 res).
  final double scaleResolutionDownBy;

  const SimulcastLayer({
    required this.rid,
    required this.width,
    required this.height,
    required this.frameRate,
    required this.maxBitrateBps,
    required this.scaleResolutionDownBy,
  });

  @override
  int get hashCode =>
      rid.hashCode ^
      width.hashCode ^
      height.hashCode ^
      frameRate.hashCode ^
      maxBitrateBps.hashCode ^
      scaleResolutionDownBy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SimulcastLayer &&
          runtimeType == other.runtimeType &&
          rid == other.rid &&
          width == other.width &&
          height == other.height &&
          frameRate == other.frameRate &&
          maxBitrateBps == other.maxBitrateBps &&
          scaleResolutionDownBy == other.scaleResolutionDownBy;
}

/// Video resolution and bitrate constraints.
class VideoConstraints {
  final int width;
  final int height;
  final int frameRate;

  /// Maximum send bitrate in bps.
  final int maxBitrateBps;

  /// Minimum send bitrate in bps.
  final int minBitrateBps;

  /// Preferred codec name ("VP8", "H264", or "VP9").
  final String preferredCodec;

  /// Whether to request hardware acceleration.
  final bool hardwareAcceleration;

  const VideoConstraints({
    required this.width,
    required this.height,
    required this.frameRate,
    required this.maxBitrateBps,
    required this.minBitrateBps,
    required this.preferredCodec,
    required this.hardwareAcceleration,
  });

  @override
  int get hashCode =>
      width.hashCode ^
      height.hashCode ^
      frameRate.hashCode ^
      maxBitrateBps.hashCode ^
      minBitrateBps.hashCode ^
      preferredCodec.hashCode ^
      hardwareAcceleration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoConstraints &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          height == other.height &&
          frameRate == other.frameRate &&
          maxBitrateBps == other.maxBitrateBps &&
          minBitrateBps == other.minBitrateBps &&
          preferredCodec == other.preferredCodec &&
          hardwareAcceleration == other.hardwareAcceleration;
}

/// Video quality preset.
enum VideoQualityPreset {
  /// 320×240 @ 15fps, ~150kbps — minimal bandwidth / battery saver.
  low,

  /// 640×480 @ 24fps, ~500kbps — good balance for mobile.
  medium,

  /// 960×720 @ 30fps, ~1200kbps — high quality on Wi-Fi.
  high,

  /// 1280×720 @ 30fps, ~2500kbps — HD on strong connections.
  hd,
}
