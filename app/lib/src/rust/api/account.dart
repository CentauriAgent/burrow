// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Create a new identity with a fresh random keypair.
/// Initializes the MDK instance and Nostr client.
Future<AccountInfo> createAccount() =>
    RustLib.instance.api.crateApiAccountCreateAccount();

/// Login with an existing secret key (nsec bech32 or hex format).
/// Initializes the MDK instance and Nostr client.
Future<AccountInfo> login({required String secretKey}) =>
    RustLib.instance.api.crateApiAccountLogin(secretKey: secretKey);

/// Save the current secret key to the platform keyring.
///
/// Uses the OS credential store (D-Bus Secret Service on Linux, Keychain on
/// macOS/iOS, Credential Manager on Android/Windows). The nsec never touches
/// the filesystem.
Future<void> saveSecretKeyToKeyring() =>
    RustLib.instance.api.crateApiAccountSaveSecretKeyToKeyring();

/// Load the secret key from the platform keyring and initialize the account.
///
/// Returns the account info if a key was found in the keyring, or an error
/// if no key is stored or the keyring is unavailable.
Future<AccountInfo> loadAccountFromKeyring() =>
    RustLib.instance.api.crateApiAccountLoadAccountFromKeyring();

/// Delete the secret key from the platform keyring (logout).
Future<void> deleteSecretKeyFromKeyring() =>
    RustLib.instance.api.crateApiAccountDeleteSecretKeyFromKeyring();

/// Check if a secret key exists in the platform keyring.
Future<bool> hasKeyringAccount() =>
    RustLib.instance.api.crateApiAccountHasKeyringAccount();

/// Save the current secret key to a file (DEPRECATED — use save_secret_key_to_keyring).
Future<void> saveSecretKey({required String filePath}) =>
    RustLib.instance.api.crateApiAccountSaveSecretKey(filePath: filePath);

/// Load a secret key from a file (DEPRECATED — use load_account_from_keyring).
Future<AccountInfo> loadAccountFromFile({required String filePath}) =>
    RustLib.instance.api.crateApiAccountLoadAccountFromFile(filePath: filePath);

/// Get the current account info, or error if not logged in.
Future<AccountInfo> getCurrentAccount() =>
    RustLib.instance.api.crateApiAccountGetCurrentAccount();

/// Logout and destroy all in-memory state.
Future<void> logout() => RustLib.instance.api.crateApiAccountLogout();

/// Check if an account is currently active.
Future<bool> isLoggedIn() => RustLib.instance.api.crateApiAccountIsLoggedIn();

/// Information about the current account (FFI-friendly).
class AccountInfo {
  /// Hex-encoded public key.
  final String pubkeyHex;

  /// Bech32-encoded public key (npub...).
  final String npub;

  const AccountInfo({required this.pubkeyHex, required this.npub});

  @override
  int get hashCode => pubkeyHex.hashCode ^ npub.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountInfo &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          npub == other.npub;
}
