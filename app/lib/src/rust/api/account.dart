// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Create a new identity with a fresh random keypair.
/// Initializes the MDK instance and Nostr client.
Future<AccountInfo> createAccount() =>
    RustLib.instance.api.crateApiAccountCreateAccount();

/// Login with an existing secret key (nsec bech32 or hex format).
/// Initializes the MDK instance and Nostr client.
Future<AccountInfo> login({required String secretKey}) =>
    RustLib.instance.api.crateApiAccountLogin(secretKey: secretKey);

/// Save the current secret key to a file with restrictive permissions (0o600).
/// The caller should provide a secure filesystem path.
/// Path traversal is prevented by rejecting paths containing `..`.
Future<void> saveSecretKey({required String filePath}) =>
    RustLib.instance.api.crateApiAccountSaveSecretKey(filePath: filePath);

/// Load a secret key from a file and initialize the account.
/// Path traversal is prevented by rejecting paths containing `..`.
Future<AccountInfo> loadAccountFromFile({required String filePath}) =>
    RustLib.instance.api.crateApiAccountLoadAccountFromFile(filePath: filePath);

/// Get the current account info, or error if not logged in.
Future<AccountInfo> getCurrentAccount() =>
    RustLib.instance.api.crateApiAccountGetCurrentAccount();

/// Logout and destroy all in-memory state.
Future<void> logout() => RustLib.instance.api.crateApiAccountLogout();

/// Check if an account is currently active.
Future<bool> isLoggedIn() => RustLib.instance.api.crateApiAccountIsLoggedIn();

/// Information about the current account (FFI-friendly).
class AccountInfo {
  /// Hex-encoded public key.
  final String pubkeyHex;

  /// Bech32-encoded public key (npub...).
  final String npub;

  const AccountInfo({required this.pubkeyHex, required this.npub});

  @override
  int get hashCode => pubkeyHex.hashCode ^ npub.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccountInfo &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          npub == other.npub;
}
