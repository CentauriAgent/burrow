// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `with_db`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `init_app_state_db`

/// Store a key-value pair for a group.
Future<void> setGroupState({
  required String groupIdHex,
  required String key,
  required String value,
}) => RustLib.instance.api.crateApiAppStateSetGroupState(
  groupIdHex: groupIdHex,
  key: key,
  value: value,
);

/// Get a value for a group.
Future<String?> getGroupState({
  required String groupIdHex,
  required String key,
}) => RustLib.instance.api.crateApiAppStateGetGroupState(
  groupIdHex: groupIdHex,
  key: key,
);

/// Delete a key for a group.
Future<void> deleteGroupState({
  required String groupIdHex,
  required String key,
}) => RustLib.instance.api.crateApiAppStateDeleteGroupState(
  groupIdHex: groupIdHex,
  key: key,
);

/// Mark a group as read up to a specific message.
Future<void> markGroupRead({
  required String groupIdHex,
  required String lastEventIdHex,
  required PlatformInt64 timestamp,
}) => RustLib.instance.api.crateApiAppStateMarkGroupRead(
  groupIdHex: groupIdHex,
  lastEventIdHex: lastEventIdHex,
  timestamp: timestamp,
);

/// Get the last-read timestamp for a group (seconds since epoch).
Future<PlatformInt64?> getLastReadTimestamp({required String groupIdHex}) =>
    RustLib.instance.api.crateApiAppStateGetLastReadTimestamp(
      groupIdHex: groupIdHex,
    );

/// Archive a group.
Future<void> archiveGroup({required String groupIdHex}) =>
    RustLib.instance.api.crateApiAppStateArchiveGroup(groupIdHex: groupIdHex);

/// Unarchive a group.
Future<void> unarchiveGroup({required String groupIdHex}) =>
    RustLib.instance.api.crateApiAppStateUnarchiveGroup(groupIdHex: groupIdHex);

/// Check if a group is archived.
Future<bool> isGroupArchived({required String groupIdHex}) => RustLib
    .instance
    .api
    .crateApiAppStateIsGroupArchived(groupIdHex: groupIdHex);

/// Get all archived group IDs.
Future<List<String>> getArchivedGroupIds() =>
    RustLib.instance.api.crateApiAppStateGetArchivedGroupIds();

/// Get the last message and unread count for a group.
///
/// Fetches the most recent message from MDK, and counts messages newer
/// than the last-read timestamp from app_state.
Future<GroupSummary> getGroupSummary({required String mlsGroupIdHex}) => RustLib
    .instance
    .api
    .crateApiAppStateGetGroupSummary(mlsGroupIdHex: mlsGroupIdHex);

/// Import archived group IDs from a list (for migrating from shared_preferences).
Future<void> importArchivedGroups({required List<String> groupIds}) => RustLib
    .instance
    .api
    .crateApiAppStateImportArchivedGroups(groupIds: groupIds);

/// Summary of a group's last message and unread count.
class GroupSummary {
  final String? lastMessageContent;
  final PlatformInt64? lastMessageTimestamp;
  final String? lastMessageAuthorHex;
  final int unreadCount;

  const GroupSummary({
    this.lastMessageContent,
    this.lastMessageTimestamp,
    this.lastMessageAuthorHex,
    required this.unreadCount,
  });

  @override
  int get hashCode =>
      lastMessageContent.hashCode ^
      lastMessageTimestamp.hashCode ^
      lastMessageAuthorHex.hashCode ^
      unreadCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupSummary &&
          runtimeType == other.runtimeType &&
          lastMessageContent == other.lastMessageContent &&
          lastMessageTimestamp == other.lastMessageTimestamp &&
          lastMessageAuthorHex == other.lastMessageAuthorHex &&
          unreadCount == other.unreadCount;
}
