// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `group_state_str`, `group_to_info`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`

/// Create a new MLS group (MIP-01).
///
/// Generates a random 32-byte Nostr group ID and configures the group with
/// the marmot_group_data extension (0xF2EE). The creator is automatically
/// added as an admin.
///
/// `member_key_package_events_json`: JSON-serialized kind 443 events for initial members.
/// Pass empty vec for a self-only group.
Future<CreateGroupResult> createGroup({
  required String name,
  required String description,
  required List<String> adminPubkeysHex,
  required List<String> memberKeyPackageEventsJson,
  required List<String> relayUrls,
}) => RustLib.instance.api.crateApiGroupCreateGroup(
  name: name,
  description: description,
  adminPubkeysHex: adminPubkeysHex,
  memberKeyPackageEventsJson: memberKeyPackageEventsJson,
  relayUrls: relayUrls,
);

/// Merge pending commit after publishing the evolution event to relays.
///
/// MUST be called after successfully publishing a kind 445 commit event.
/// This prevents state forks per MIP-02.
Future<void> mergePendingCommit({required String mlsGroupIdHex}) => RustLib
    .instance
    .api
    .crateApiGroupMergePendingCommit(mlsGroupIdHex: mlsGroupIdHex);

/// List all groups the current user belongs to.
Future<List<GroupInfo>> listGroups() =>
    RustLib.instance.api.crateApiGroupListGroups();

/// Get info about a specific group by its MLS group ID.
Future<GroupInfo> getGroup({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupGetGroup(mlsGroupIdHex: mlsGroupIdHex);

/// Get members of a group, enriched with cached profile data.
Future<List<MemberInfo>> getGroupMembers({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupGetGroupMembers(
      mlsGroupIdHex: mlsGroupIdHex,
    );

/// Leave a group. Creates a leave proposal that must be committed by an admin.
///
/// Returns an evolution event (kind 445) to publish to group relays.
Future<UpdateGroupResult> leaveGroup({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupLeaveGroup(mlsGroupIdHex: mlsGroupIdHex);

/// Get the relay URLs configured for a group.
Future<List<String>> getGroupRelays({required String mlsGroupIdHex}) => RustLib
    .instance
    .api
    .crateApiGroupGetGroupRelays(mlsGroupIdHex: mlsGroupIdHex);

/// Update the relay URLs for a group. Admin-only.
/// Returns an evolution event to publish to the old and new relays.
Future<UpdateGroupResult> updateGroupRelays({
  required String mlsGroupIdHex,
  required List<String> relayUrls,
}) => RustLib.instance.api.crateApiGroupUpdateGroupRelays(
  mlsGroupIdHex: mlsGroupIdHex,
  relayUrls: relayUrls,
);

/// Update group metadata (name, description). Admin-only.
Future<UpdateGroupResult> updateGroupName({
  required String mlsGroupIdHex,
  required String name,
}) => RustLib.instance.api.crateApiGroupUpdateGroupName(
  mlsGroupIdHex: mlsGroupIdHex,
  name: name,
);

/// Result of creating a group, including welcome events for invited members.
class CreateGroupResult {
  /// The created group info.
  final GroupInfo group;

  /// JSON-serialized welcome rumor events (kind 444) to be gift-wrapped and sent to invitees.
  final List<String> welcomeRumorsJson;

  /// Hex-encoded MLS group ID for subsequent operations.
  final String mlsGroupIdHex;

  const CreateGroupResult({
    required this.group,
    required this.welcomeRumorsJson,
    required this.mlsGroupIdHex,
  });

  @override
  int get hashCode =>
      group.hashCode ^ welcomeRumorsJson.hashCode ^ mlsGroupIdHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateGroupResult &&
          runtimeType == other.runtimeType &&
          group == other.group &&
          welcomeRumorsJson == other.welcomeRumorsJson &&
          mlsGroupIdHex == other.mlsGroupIdHex;
}

/// Group information flattened for FFI.
class GroupInfo {
  /// Hex-encoded MLS group ID (internal protocol identifier).
  final String mlsGroupIdHex;

  /// Hex-encoded Nostr group ID (used for relay message routing via `h` tag).
  final String nostrGroupIdHex;

  /// Human-readable group name.
  final String name;

  /// Group description.
  final String description;

  /// Hex-encoded admin public keys.
  final List<String> adminPubkeys;

  /// Current MLS epoch.
  final BigInt epoch;

  /// Group state: "active", "pending", or "inactive".
  final String state;

  /// Number of members in the group.
  final int memberCount;

  /// Whether this is a 1:1 direct message group (2 members, including self).
  final bool isDirectMessage;

  /// For DMs: the peer's display name (from profile cache). None for groups.
  final String? dmPeerDisplayName;

  /// For DMs: the peer's profile picture URL. None for groups.
  final String? dmPeerPicture;

  /// For DMs: the peer's pubkey hex. None for groups.
  final String? dmPeerPubkeyHex;

  const GroupInfo({
    required this.mlsGroupIdHex,
    required this.nostrGroupIdHex,
    required this.name,
    required this.description,
    required this.adminPubkeys,
    required this.epoch,
    required this.state,
    required this.memberCount,
    required this.isDirectMessage,
    this.dmPeerDisplayName,
    this.dmPeerPicture,
    this.dmPeerPubkeyHex,
  });

  @override
  int get hashCode =>
      mlsGroupIdHex.hashCode ^
      nostrGroupIdHex.hashCode ^
      name.hashCode ^
      description.hashCode ^
      adminPubkeys.hashCode ^
      epoch.hashCode ^
      state.hashCode ^
      memberCount.hashCode ^
      isDirectMessage.hashCode ^
      dmPeerDisplayName.hashCode ^
      dmPeerPicture.hashCode ^
      dmPeerPubkeyHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupInfo &&
          runtimeType == other.runtimeType &&
          mlsGroupIdHex == other.mlsGroupIdHex &&
          nostrGroupIdHex == other.nostrGroupIdHex &&
          name == other.name &&
          description == other.description &&
          adminPubkeys == other.adminPubkeys &&
          epoch == other.epoch &&
          state == other.state &&
          memberCount == other.memberCount &&
          isDirectMessage == other.isDirectMessage &&
          dmPeerDisplayName == other.dmPeerDisplayName &&
          dmPeerPicture == other.dmPeerPicture &&
          dmPeerPubkeyHex == other.dmPeerPubkeyHex;
}

/// Member information for FFI, enriched with cached profile data.
class MemberInfo {
  /// Hex-encoded public key of the member.
  final String pubkeyHex;

  /// Display name from cached profile (if available).
  final String? displayName;

  /// Profile picture URL from cached profile (if available).
  final String? picture;

  const MemberInfo({required this.pubkeyHex, this.displayName, this.picture});

  @override
  int get hashCode =>
      pubkeyHex.hashCode ^ displayName.hashCode ^ picture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemberInfo &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          displayName == other.displayName &&
          picture == other.picture;
}

/// Result of a group update operation (add/remove members, leave, etc.).
class UpdateGroupResult {
  /// JSON-serialized kind 445 evolution event to publish to group relays.
  final String evolutionEventJson;

  /// JSON-serialized welcome rumor events for newly added members (if any).
  final List<String> welcomeRumorsJson;

  /// Hex-encoded MLS group ID this update applies to.
  final String mlsGroupIdHex;

  const UpdateGroupResult({
    required this.evolutionEventJson,
    required this.welcomeRumorsJson,
    required this.mlsGroupIdHex,
  });

  @override
  int get hashCode =>
      evolutionEventJson.hashCode ^
      welcomeRumorsJson.hashCode ^
      mlsGroupIdHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateGroupResult &&
          runtimeType == other.runtimeType &&
          evolutionEventJson == other.evolutionEventJson &&
          welcomeRumorsJson == other.welcomeRumorsJson &&
          mlsGroupIdHex == other.mlsGroupIdHex;
}
