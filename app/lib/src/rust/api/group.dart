// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `base64_encode`, `group_state_str`, `group_to_info`, `sha256_hex`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Create a new MLS group (MIP-01).
///
/// Generates a random 32-byte Nostr group ID and configures the group with
/// the marmot_group_data extension (0xF2EE). The creator is automatically
/// added as an admin.
///
/// `member_key_package_events_json`: JSON-serialized kind 443 events for initial members.
/// Pass empty vec for a self-only group.
Future<CreateGroupResult> createGroup({
  required String name,
  required String description,
  required List<String> adminPubkeysHex,
  required List<String> memberKeyPackageEventsJson,
  required List<String> relayUrls,
}) => RustLib.instance.api.crateApiGroupCreateGroup(
  name: name,
  description: description,
  adminPubkeysHex: adminPubkeysHex,
  memberKeyPackageEventsJson: memberKeyPackageEventsJson,
  relayUrls: relayUrls,
);

/// Merge pending commit after publishing the evolution event to relays.
///
/// MUST be called after successfully publishing a kind 445 commit event.
/// This prevents state forks per MIP-02.
Future<void> mergePendingCommit({required String mlsGroupIdHex}) => RustLib
    .instance
    .api
    .crateApiGroupMergePendingCommit(mlsGroupIdHex: mlsGroupIdHex);

/// List all groups the current user belongs to.
Future<List<GroupInfo>> listGroups() =>
    RustLib.instance.api.crateApiGroupListGroups();

/// Get info about a specific group by its MLS group ID.
Future<GroupInfo> getGroup({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupGetGroup(mlsGroupIdHex: mlsGroupIdHex);

/// Get members of a group, enriched with cached profile data.
Future<List<MemberInfo>> getGroupMembers({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupGetGroupMembers(
      mlsGroupIdHex: mlsGroupIdHex,
    );

/// Leave a group. Creates a leave proposal that must be committed by an admin.
///
/// Returns an evolution event (kind 445) to publish to group relays.
Future<UpdateGroupResult> leaveGroup({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupLeaveGroup(mlsGroupIdHex: mlsGroupIdHex);

/// Upload and set a group avatar image via encrypted Blossom (MIP-01).
///
/// 1. Validates and encrypts the image using MDK's `prepare_group_image_for_upload`.
/// 2. Uploads the encrypted blob to the Blossom server with NIP-98 auth.
/// 3. Updates the MLS group extension with image_hash/key/nonce/upload_key.
/// 4. Returns the evolution event to publish to relays.
Future<UploadGroupImageResult> uploadGroupImage({
  required String mlsGroupIdHex,
  required List<int> imageData,
  required String mimeType,
  required String blossomServerUrl,
}) => RustLib.instance.api.crateApiGroupUploadGroupImage(
  mlsGroupIdHex: mlsGroupIdHex,
  imageData: imageData,
  mimeType: mimeType,
  blossomServerUrl: blossomServerUrl,
);

/// Download and decrypt a group's avatar image from Blossom.
///
/// Fetches the encrypted blob using the group's image_hash, then decrypts
/// using the image_key and image_nonce from the MLS group extension.
///
/// Returns the decrypted image bytes, or an error if the group has no image.
Future<Uint8List> downloadGroupImage({
  required String mlsGroupIdHex,
  required String blossomServerUrl,
}) => RustLib.instance.api.crateApiGroupDownloadGroupImage(
  mlsGroupIdHex: mlsGroupIdHex,
  blossomServerUrl: blossomServerUrl,
);

/// Remove a group's avatar image. Clears the MLS extension and optionally
/// deletes the blob from Blossom.
///
/// Returns the evolution event to publish to relays.
Future<UpdateGroupResult> removeGroupImage({required String mlsGroupIdHex}) =>
    RustLib.instance.api.crateApiGroupRemoveGroupImage(
      mlsGroupIdHex: mlsGroupIdHex,
    );

/// Default Blossom server URL.
Future<String> defaultBlossomServer() =>
    RustLib.instance.api.crateApiGroupDefaultBlossomServer();

/// Get the relay URLs configured for a group.
Future<List<String>> getGroupRelays({required String mlsGroupIdHex}) => RustLib
    .instance
    .api
    .crateApiGroupGetGroupRelays(mlsGroupIdHex: mlsGroupIdHex);

/// Update the relay URLs for a group. Admin-only.
/// Returns an evolution event to publish to the old and new relays.
Future<UpdateGroupResult> updateGroupRelays({
  required String mlsGroupIdHex,
  required List<String> relayUrls,
}) => RustLib.instance.api.crateApiGroupUpdateGroupRelays(
  mlsGroupIdHex: mlsGroupIdHex,
  relayUrls: relayUrls,
);

/// Update group name. Admin-only.
Future<UpdateGroupResult> updateGroupName({
  required String mlsGroupIdHex,
  required String name,
}) => RustLib.instance.api.crateApiGroupUpdateGroupName(
  mlsGroupIdHex: mlsGroupIdHex,
  name: name,
);

/// Update group description. Admin-only.
Future<UpdateGroupResult> updateGroupDescription({
  required String mlsGroupIdHex,
  required String description,
}) => RustLib.instance.api.crateApiGroupUpdateGroupDescription(
  mlsGroupIdHex: mlsGroupIdHex,
  description: description,
);

/// Result of creating a group, including welcome events for invited members.
class CreateGroupResult {
  /// The created group info.
  final GroupInfo group;

  /// JSON-serialized welcome rumor events (kind 444) to be gift-wrapped and sent to invitees.
  final List<String> welcomeRumorsJson;

  /// Hex-encoded MLS group ID for subsequent operations.
  final String mlsGroupIdHex;

  const CreateGroupResult({
    required this.group,
    required this.welcomeRumorsJson,
    required this.mlsGroupIdHex,
  });

  @override
  int get hashCode =>
      group.hashCode ^ welcomeRumorsJson.hashCode ^ mlsGroupIdHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateGroupResult &&
          runtimeType == other.runtimeType &&
          group == other.group &&
          welcomeRumorsJson == other.welcomeRumorsJson &&
          mlsGroupIdHex == other.mlsGroupIdHex;
}

/// Group information flattened for FFI.
class GroupInfo {
  /// Hex-encoded MLS group ID (internal protocol identifier).
  final String mlsGroupIdHex;

  /// Hex-encoded Nostr group ID (used for relay message routing via `h` tag).
  final String nostrGroupIdHex;

  /// Human-readable group name.
  final String name;

  /// Group description.
  final String description;

  /// Hex-encoded admin public keys.
  final List<String> adminPubkeys;

  /// Current MLS epoch.
  final BigInt epoch;

  /// Group state: "active", "pending", or "inactive".
  final String state;

  /// Number of members in the group.
  final int memberCount;

  /// Whether this is a 1:1 direct message group (2 members, including self).
  final bool isDirectMessage;

  /// For DMs: the peer's display name (from profile cache). None for groups.
  final String? dmPeerDisplayName;

  /// For DMs: the peer's profile picture URL. None for groups.
  final String? dmPeerPicture;

  /// For DMs: the peer's pubkey hex. None for groups.
  final String? dmPeerPubkeyHex;

  /// Hex-encoded SHA-256 hash of encrypted group avatar on Blossom. None if no avatar.
  final String? imageHashHex;

  /// Whether this group has an avatar image set.
  final bool hasImage;

  const GroupInfo({
    required this.mlsGroupIdHex,
    required this.nostrGroupIdHex,
    required this.name,
    required this.description,
    required this.adminPubkeys,
    required this.epoch,
    required this.state,
    required this.memberCount,
    required this.isDirectMessage,
    this.dmPeerDisplayName,
    this.dmPeerPicture,
    this.dmPeerPubkeyHex,
    this.imageHashHex,
    required this.hasImage,
  });

  @override
  int get hashCode =>
      mlsGroupIdHex.hashCode ^
      nostrGroupIdHex.hashCode ^
      name.hashCode ^
      description.hashCode ^
      adminPubkeys.hashCode ^
      epoch.hashCode ^
      state.hashCode ^
      memberCount.hashCode ^
      isDirectMessage.hashCode ^
      dmPeerDisplayName.hashCode ^
      dmPeerPicture.hashCode ^
      dmPeerPubkeyHex.hashCode ^
      imageHashHex.hashCode ^
      hasImage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupInfo &&
          runtimeType == other.runtimeType &&
          mlsGroupIdHex == other.mlsGroupIdHex &&
          nostrGroupIdHex == other.nostrGroupIdHex &&
          name == other.name &&
          description == other.description &&
          adminPubkeys == other.adminPubkeys &&
          epoch == other.epoch &&
          state == other.state &&
          memberCount == other.memberCount &&
          isDirectMessage == other.isDirectMessage &&
          dmPeerDisplayName == other.dmPeerDisplayName &&
          dmPeerPicture == other.dmPeerPicture &&
          dmPeerPubkeyHex == other.dmPeerPubkeyHex &&
          imageHashHex == other.imageHashHex &&
          hasImage == other.hasImage;
}

/// Member information for FFI, enriched with cached profile data.
class MemberInfo {
  /// Hex-encoded public key of the member.
  final String pubkeyHex;

  /// Display name from cached profile (if available).
  final String? displayName;

  /// Profile picture URL from cached profile (if available).
  final String? picture;

  const MemberInfo({required this.pubkeyHex, this.displayName, this.picture});

  @override
  int get hashCode =>
      pubkeyHex.hashCode ^ displayName.hashCode ^ picture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemberInfo &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          displayName == other.displayName &&
          picture == other.picture;
}

/// Result of a group update operation (add/remove members, leave, etc.).
class UpdateGroupResult {
  /// JSON-serialized kind 445 evolution event to publish to group relays.
  final String evolutionEventJson;

  /// JSON-serialized welcome rumor events for newly added members (if any).
  final List<String> welcomeRumorsJson;

  /// Hex-encoded MLS group ID this update applies to.
  final String mlsGroupIdHex;

  const UpdateGroupResult({
    required this.evolutionEventJson,
    required this.welcomeRumorsJson,
    required this.mlsGroupIdHex,
  });

  @override
  int get hashCode =>
      evolutionEventJson.hashCode ^
      welcomeRumorsJson.hashCode ^
      mlsGroupIdHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UpdateGroupResult &&
          runtimeType == other.runtimeType &&
          evolutionEventJson == other.evolutionEventJson &&
          welcomeRumorsJson == other.welcomeRumorsJson &&
          mlsGroupIdHex == other.mlsGroupIdHex;
}

/// Result of uploading a group image to Blossom.
class UploadGroupImageResult {
  /// Evolution event JSON (kind 445) to publish to relays.
  final String evolutionEventJson;

  /// Hex-encoded SHA-256 of the encrypted blob (Blossom content address).
  final String encryptedHashHex;

  /// Hex-encoded MLS group ID.
  final String mlsGroupIdHex;

  const UploadGroupImageResult({
    required this.evolutionEventJson,
    required this.encryptedHashHex,
    required this.mlsGroupIdHex,
  });

  @override
  int get hashCode =>
      evolutionEventJson.hashCode ^
      encryptedHashHex.hashCode ^
      mlsGroupIdHex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UploadGroupImageResult &&
          runtimeType == other.runtimeType &&
          evolutionEventJson == other.evolutionEventJson &&
          encryptedHashHex == other.encryptedHashHex &&
          mlsGroupIdHex == other.mlsGroupIdHex;
}
