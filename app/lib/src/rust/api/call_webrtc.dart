// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `compute_quality_score`, `now_secs`, `parse_sdp_internal`, `peer_stats_store`, `peers`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Generate WebRTC configuration with STUN-only ICE servers.
///
/// Returns STUN server configuration for creating peer connections.
/// STUN is sufficient for most NAT traversal scenarios.
///
/// TURN relay is NOT included by default because proper TURN authentication
/// requires server-side credential provisioning (e.g., time-limited HMAC
/// credentials via a TURN REST API, or an API key from a hosted provider
/// like metered.ca / Twilio / Xirsys). Client-side credential generation
/// provides no security â€” anyone can derive the same credentials.
///
/// Users who need TURN relay (e.g., behind symmetric NATs or strict
/// firewalls) should configure their own TURN server credentials in the
/// app settings (Settings > TURN Server). The Dart WebRTC service layer
/// will merge user-configured TURN servers into the ICE server list.
///
/// `call_id`: Call identifier (unused currently, reserved for future use).
Future<WebRtcConfig> generateWebrtcConfig({required String callId}) =>
    RustLib.instance.api.crateApiCallWebrtcGenerateWebrtcConfig(callId: callId);

/// Parse and validate an SDP offer string.
///
/// Extracts media types, codecs, and validates basic SDP structure.
Future<SdpInfo> parseSdpOffer({required String sdp}) =>
    RustLib.instance.api.crateApiCallWebrtcParseSdpOffer(sdp: sdp);

/// Parse and validate an SDP answer string.
Future<SdpInfo> parseSdpAnswer({required String sdp}) =>
    RustLib.instance.api.crateApiCallWebrtcParseSdpAnswer(sdp: sdp);

/// Create a new peer entry to track a WebRTC peer connection.
///
/// Called when a new participant joins a call or a new P2P connection is established.
Future<PeerEntry> createPeerEntry({
  required String callId,
  required String participantPubkeyHex,
  required bool hasAudioTrack,
  required bool hasVideoTrack,
}) => RustLib.instance.api.crateApiCallWebrtcCreatePeerEntry(
  callId: callId,
  participantPubkeyHex: participantPubkeyHex,
  hasAudioTrack: hasAudioTrack,
  hasVideoTrack: hasVideoTrack,
);

/// Update the connection state of a tracked peer.
///
/// `state`: One of "new", "checking", "connected", "disconnected", "failed", "closed".
Future<PeerEntry> updatePeerState({
  required String callId,
  required String participantPubkeyHex,
  required String state,
}) => RustLib.instance.api.crateApiCallWebrtcUpdatePeerState(
  callId: callId,
  participantPubkeyHex: participantPubkeyHex,
  state: state,
);

/// Report connection quality metrics for a peer (called from Dart with WebRTC stats).
Future<PeerStats> reportPeerStats({
  required String participantPubkeyHex,
  double? rttMs,
  double? packetLossPercent,
  double? outgoingBitrateKbps,
  double? incomingBitrateKbps,
}) => RustLib.instance.api.crateApiCallWebrtcReportPeerStats(
  participantPubkeyHex: participantPubkeyHex,
  rttMs: rttMs,
  packetLossPercent: packetLossPercent,
  outgoingBitrateKbps: outgoingBitrateKbps,
  incomingBitrateKbps: incomingBitrateKbps,
);

/// Get the latest connection quality metrics for a peer.
Future<PeerStats?> getPeerStats({required String participantPubkeyHex}) =>
    RustLib.instance.api.crateApiCallWebrtcGetPeerStats(
      participantPubkeyHex: participantPubkeyHex,
    );

/// Get all participants in a call with their connection states.
Future<List<PeerEntry>> getCallParticipants({required String callId}) =>
    RustLib.instance.api.crateApiCallWebrtcGetCallParticipants(callId: callId);

/// Remove all peer entries for a call (cleanup).
Future<void> removeCallPeers({required String callId}) =>
    RustLib.instance.api.crateApiCallWebrtcRemoveCallPeers(callId: callId);

/// Derive a per-call AES-128-GCM frame encryption key from MLS exporter_secret.
///
/// Used for SFU mode where frames must be encrypted end-to-end since DTLS
/// terminates at the SFU. The key is derived deterministically so all group
/// members compute the same key from their shared MLS state.
///
/// `exporter_secret_hex`: Hex-encoded MLS exporter_secret from the group epoch.
/// `call_id`: Unique call identifier used as derivation context.
///
/// Returns 16-byte (128-bit) AES-GCM key as hex string.
Future<String> deriveFrameEncryptionKey({
  required String exporterSecretHex,
  required String callId,
}) => RustLib.instance.api.crateApiCallWebrtcDeriveFrameEncryptionKey(
  exporterSecretHex: exporterSecretHex,
  callId: callId,
);

/// Rotate the frame encryption key by deriving a new key from the current key + epoch.
///
/// Called when MLS epoch advances (member join/leave/update) to maintain forward secrecy.
///
/// `current_key_hex`: Current frame encryption key (hex).
/// `new_epoch`: The new MLS epoch number.
/// `call_id`: Call identifier for context binding.
///
/// Returns new 16-byte AES-GCM key as hex string.
Future<String> rotateFrameKey({
  required String currentKeyHex,
  required BigInt newEpoch,
  required String callId,
}) => RustLib.instance.api.crateApiCallWebrtcRotateFrameKey(
  currentKeyHex: currentKeyHex,
  newEpoch: newEpoch,
  callId: callId,
);

/// Determine whether a call should use SFU (true) or P2P mesh (false).
///
/// `participant_count`: Number of participants in the call (including local user).
///
/// Returns true if SFU should be used (participant_count > 4).
Future<bool> shouldUseSfu({required int participantCount}) => RustLib
    .instance
    .api
    .crateApiCallWebrtcShouldUseSfu(participantCount: participantCount);

/// Get SFU configuration for a group call that requires SFU mode.
///
/// `call_id`: The call identifier (used to derive room name).
/// `local_pubkey_hex`: Local user's public key (used in token).
///
/// Returns SFU connection details. In production, the token would be obtained
/// from a Burrow coordination server. For now, returns placeholder config.
Future<SfuConfig> getSfuConfig({
  required String callId,
  required String localPubkeyHex,
}) => RustLib.instance.api.crateApiCallWebrtcGetSfuConfig(
  callId: callId,
  localPubkeyHex: localPubkeyHex,
);

/// A single ICE server entry for WebRTC peer connection configuration.
class IceServer {
  final List<String> urls;
  final String? username;
  final String? credential;

  const IceServer({required this.urls, this.username, this.credential});

  @override
  int get hashCode => urls.hashCode ^ username.hashCode ^ credential.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IceServer &&
          runtimeType == other.runtimeType &&
          urls == other.urls &&
          username == other.username &&
          credential == other.credential;
}

/// State of a WebRTC peer connection.
enum PeerConnectionState {
  new_,
  checking,
  connected,
  disconnected,
  failed,
  closed,
}

/// Tracked peer connection entry.
class PeerEntry {
  /// Hex-encoded public key of the remote participant.
  final String participantPubkeyHex;

  /// Current connection state.
  final PeerConnectionState connectionState;

  /// Call ID this peer belongs to.
  final String callId;

  /// Whether the peer has an audio track.
  final bool hasAudioTrack;

  /// Whether the peer has a video track.
  final bool hasVideoTrack;

  /// Whether the remote peer is muted.
  final bool isRemoteMuted;

  /// Whether the remote peer has video enabled.
  final bool isRemoteVideoEnabled;

  /// Unix timestamp when this peer entry was created.
  final BigInt createdAt;

  /// Unix timestamp of last state update.
  final BigInt updatedAt;

  const PeerEntry({
    required this.participantPubkeyHex,
    required this.connectionState,
    required this.callId,
    required this.hasAudioTrack,
    required this.hasVideoTrack,
    required this.isRemoteMuted,
    required this.isRemoteVideoEnabled,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      participantPubkeyHex.hashCode ^
      connectionState.hashCode ^
      callId.hashCode ^
      hasAudioTrack.hashCode ^
      hasVideoTrack.hashCode ^
      isRemoteMuted.hashCode ^
      isRemoteVideoEnabled.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerEntry &&
          runtimeType == other.runtimeType &&
          participantPubkeyHex == other.participantPubkeyHex &&
          connectionState == other.connectionState &&
          callId == other.callId &&
          hasAudioTrack == other.hasAudioTrack &&
          hasVideoTrack == other.hasVideoTrack &&
          isRemoteMuted == other.isRemoteMuted &&
          isRemoteVideoEnabled == other.isRemoteVideoEnabled &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Connection quality metrics for a peer.
class PeerStats {
  /// Hex-encoded public key of the peer.
  final String participantPubkeyHex;

  /// Round-trip time in milliseconds.
  final double? rttMs;

  /// Packet loss percentage (0.0 - 100.0).
  final double? packetLossPercent;

  /// Outgoing bitrate in kbps.
  final double? outgoingBitrateKbps;

  /// Incoming bitrate in kbps.
  final double? incomingBitrateKbps;

  /// Connection quality score (0.0 - 1.0).
  final double? qualityScore;

  /// Unix timestamp of this stats snapshot.
  final BigInt timestamp;

  const PeerStats({
    required this.participantPubkeyHex,
    this.rttMs,
    this.packetLossPercent,
    this.outgoingBitrateKbps,
    this.incomingBitrateKbps,
    this.qualityScore,
    required this.timestamp,
  });

  @override
  int get hashCode =>
      participantPubkeyHex.hashCode ^
      rttMs.hashCode ^
      packetLossPercent.hashCode ^
      outgoingBitrateKbps.hashCode ^
      incomingBitrateKbps.hashCode ^
      qualityScore.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerStats &&
          runtimeType == other.runtimeType &&
          participantPubkeyHex == other.participantPubkeyHex &&
          rttMs == other.rttMs &&
          packetLossPercent == other.packetLossPercent &&
          outgoingBitrateKbps == other.outgoingBitrateKbps &&
          incomingBitrateKbps == other.incomingBitrateKbps &&
          qualityScore == other.qualityScore &&
          timestamp == other.timestamp;
}

/// Extracted information from an SDP offer or answer.
class SdpInfo {
  /// "offer" or "answer".
  final String sdpType;

  /// Whether audio media is present.
  final bool hasAudio;

  /// Whether video media is present.
  final bool hasVideo;

  /// Number of media sections (m= lines).
  final int mediaCount;

  /// ICE ufrag if found.
  final String? iceUfrag;

  /// Detected codecs (e.g. "opus", "VP8", "H264").
  final List<String> codecs;

  /// Whether the SDP appears valid.
  final bool isValid;

  /// Validation error message, if any.
  final String? error;

  const SdpInfo({
    required this.sdpType,
    required this.hasAudio,
    required this.hasVideo,
    required this.mediaCount,
    this.iceUfrag,
    required this.codecs,
    required this.isValid,
    this.error,
  });

  @override
  int get hashCode =>
      sdpType.hashCode ^
      hasAudio.hashCode ^
      hasVideo.hashCode ^
      mediaCount.hashCode ^
      iceUfrag.hashCode ^
      codecs.hashCode ^
      isValid.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SdpInfo &&
          runtimeType == other.runtimeType &&
          sdpType == other.sdpType &&
          hasAudio == other.hasAudio &&
          hasVideo == other.hasVideo &&
          mediaCount == other.mediaCount &&
          iceUfrag == other.iceUfrag &&
          codecs == other.codecs &&
          isValid == other.isValid &&
          error == other.error;
}

/// SFU configuration for LiveKit-based group calls.
class SfuConfig {
  /// LiveKit server WebSocket URL.
  final String serverUrl;

  /// Room name (derived from call_id).
  final String roomName;

  /// Authentication token for joining the room.
  final String token;

  const SfuConfig({
    required this.serverUrl,
    required this.roomName,
    required this.token,
  });

  @override
  int get hashCode => serverUrl.hashCode ^ roomName.hashCode ^ token.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SfuConfig &&
          runtimeType == other.runtimeType &&
          serverUrl == other.serverUrl &&
          roomName == other.roomName &&
          token == other.token;
}

/// Full WebRTC configuration returned to Dart for creating RTCPeerConnection.
class WebRtcConfig {
  final List<IceServer> iceServers;

  /// "unified-plan" (only supported value).
  final String sdpSemantics;

  /// Bundle policy: "max-bundle".
  final String bundlePolicy;

  const WebRtcConfig({
    required this.iceServers,
    required this.sdpSemantics,
    required this.bundlePolicy,
  });

  @override
  int get hashCode =>
      iceServers.hashCode ^ sdpSemantics.hashCode ^ bundlePolicy.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebRtcConfig &&
          runtimeType == other.runtimeType &&
          iceServers == other.iceServers &&
          sdpSemantics == other.sdpSemantics &&
          bundlePolicy == other.bundlePolicy;
}
