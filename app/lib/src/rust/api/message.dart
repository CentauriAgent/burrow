// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

/// Send an encrypted message to a group (MIP-03).
///
/// Creates a plaintext rumor, MLS-encrypts it, NIP-44-encrypts with exporter_secret,
/// signs with an ephemeral key, and returns a kind 445 event ready for relay publication.
///
/// Returns JSON-serialized signed Event (kind 445).
Future<String> sendMessage({
  required String mlsGroupIdHex,
  required String content,
}) => RustLib.instance.api.crateApiMessageSendMessage(
  mlsGroupIdHex: mlsGroupIdHex,
  content: content,
);

/// Send an encrypted message with media attachment(s) to a group.
///
/// Same as `send_message` but includes imeta tags for encrypted media references.
/// The `imeta_tags_json` is a JSON array of arrays, where each inner array is
/// a flat string list like `["imeta", "url ...", "m ...", ...]`.
///
/// Returns JSON-serialized signed Event (kind 445).
Future<String> sendMessageWithMedia({
  required String mlsGroupIdHex,
  required String content,
  required List<List<String>> imetaTagsJson,
}) => RustLib.instance.api.crateApiMessageSendMessageWithMedia(
  mlsGroupIdHex: mlsGroupIdHex,
  content: content,
  imetaTagsJson: imetaTagsJson,
);

/// Send an encrypted reaction to a message in a group (NIP-25 over MLS).
///
/// Creates a kind 7 rumor with the emoji as content and an `e` tag referencing
/// the target message's event ID. The rumor is MLS-encrypted and published
/// as a kind 445 event, same as regular messages.
///
/// Returns JSON-serialized signed Event (kind 445).
Future<String> sendReaction({
  required String mlsGroupIdHex,
  required String targetEventIdHex,
  required String emoji,
}) => RustLib.instance.api.crateApiMessageSendReaction(
  mlsGroupIdHex: mlsGroupIdHex,
  targetEventIdHex: targetEventIdHex,
  emoji: emoji,
);

/// Process an incoming kind 445 group message event.
///
/// Decrypts the NIP-44 layer using the group's exporter_secret, then MLS-decrypts
/// to recover the plaintext rumor. Handles application messages, commits, and proposals.
///
/// `event_json`: JSON-serialized kind 445 Event received from a relay.
Future<ProcessMessageResult> processMessage({required String eventJson}) =>
    RustLib.instance.api.crateApiMessageProcessMessage(eventJson: eventJson);

/// Get message history for a group with optional pagination.
///
/// Returns messages ordered by creation time (descending).
Future<List<GroupMessage>> getMessages({
  required String mlsGroupIdHex,
  int? limit,
  int? offset,
}) => RustLib.instance.api.crateApiMessageGetMessages(
  mlsGroupIdHex: mlsGroupIdHex,
  limit: limit,
  offset: offset,
);

/// Get a specific message by its event ID within a group.
Future<GroupMessage> getMessage({
  required String mlsGroupIdHex,
  required String eventIdHex,
}) => RustLib.instance.api.crateApiMessageGetMessage(
  mlsGroupIdHex: mlsGroupIdHex,
  eventIdHex: eventIdHex,
);

/// Build a Nostr filter for subscribing to group messages on relays.
///
/// Returns a JSON-serialized Filter for kind 445 events with the group's `h` tag.
/// Use this with the Nostr client to subscribe to real-time group messages.
Future<String> groupMessageFilter({required String mlsGroupIdHex}) => RustLib
    .instance
    .api
    .crateApiMessageGroupMessageFilter(mlsGroupIdHex: mlsGroupIdHex);

/// Fetch and process missed group messages from relays (catch-up sync).
///
/// For each group, queries relays for kind 445 events and processes them
/// through MDK's `process_message`. Returns the count of new messages found.
/// Call this on app startup before `listen_for_group_messages` to catch
/// messages sent while the app was offline.
Future<int> syncGroupMessages() =>
    RustLib.instance.api.crateApiMessageSyncGroupMessages();

/// Subscribe to kind 445 group message events for all groups and stream
/// decrypted messages to the Dart side.
///
/// Builds a filter for each active group's Nostr group ID, subscribes to
/// connected relays, and processes incoming events through MDK's
/// `process_message` pipeline. Only `ApplicationMessage` results (actual
/// chat messages) are forwarded; commits and proposals are handled silently.
///
/// Runs indefinitely until the stream is closed from the Dart side.
Stream<GroupMessage> listenForGroupMessages() =>
    RustLib.instance.api.crateApiMessageListenForGroupMessages();

/// A decrypted group message, flattened for FFI.
class GroupMessage {
  /// Hex-encoded event ID of the inner rumor (the actual message).
  final String eventIdHex;

  /// Hex-encoded public key of the message author.
  final String authorPubkeyHex;

  /// Message content (plaintext after decryption).
  final String content;

  /// Unix timestamp of message creation.
  final BigInt createdAt;

  /// Hex-encoded MLS group ID this message belongs to.
  final String mlsGroupIdHex;

  /// Message kind (usually 1 for text).
  final BigInt kind;

  /// Tags from the inner rumor as flat string arrays.
  final List<List<String>> tags;

  /// Hex-encoded wrapper event ID (the kind 445 event on relays).
  final String wrapperEventIdHex;

  /// MLS epoch when this message was created.
  final BigInt epoch;

  const GroupMessage({
    required this.eventIdHex,
    required this.authorPubkeyHex,
    required this.content,
    required this.createdAt,
    required this.mlsGroupIdHex,
    required this.kind,
    required this.tags,
    required this.wrapperEventIdHex,
    required this.epoch,
  });

  @override
  int get hashCode =>
      eventIdHex.hashCode ^
      authorPubkeyHex.hashCode ^
      content.hashCode ^
      createdAt.hashCode ^
      mlsGroupIdHex.hashCode ^
      kind.hashCode ^
      tags.hashCode ^
      wrapperEventIdHex.hashCode ^
      epoch.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupMessage &&
          runtimeType == other.runtimeType &&
          eventIdHex == other.eventIdHex &&
          authorPubkeyHex == other.authorPubkeyHex &&
          content == other.content &&
          createdAt == other.createdAt &&
          mlsGroupIdHex == other.mlsGroupIdHex &&
          kind == other.kind &&
          tags == other.tags &&
          wrapperEventIdHex == other.wrapperEventIdHex &&
          epoch == other.epoch;
}

/// Result of processing an incoming kind 445 event.
class ProcessMessageResult {
  /// "application_message", "commit", "proposal", "pending_proposal", "unprocessable"
  final String resultType;

  /// The decrypted message (only set for "application_message").
  final GroupMessage? message;

  /// Hex-encoded MLS group ID (set for all types).
  final String mlsGroupIdHex;

  /// For proposal results, JSON-serialized evolution event to publish.
  final String? evolutionEventJson;

  const ProcessMessageResult({
    required this.resultType,
    this.message,
    required this.mlsGroupIdHex,
    this.evolutionEventJson,
  });

  @override
  int get hashCode =>
      resultType.hashCode ^
      message.hashCode ^
      mlsGroupIdHex.hashCode ^
      evolutionEventJson.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProcessMessageResult &&
          runtimeType == other.runtimeType &&
          resultType == other.resultType &&
          message == other.message &&
          mlsGroupIdHex == other.mlsGroupIdHex &&
          evolutionEventJson == other.evolutionEventJson;
}
