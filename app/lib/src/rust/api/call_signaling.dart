// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `build_gift_wrapped_signaling`, `signaling_tags`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CallAnswerPayload`, `CallOfferPayload`, `CallStateUpdatePayload`, `IceCandidatePayload`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Initiate a call by creating a gift-wrapped call offer event (kind 25050).
///
/// `sdp_offer`: SDP offer string from WebRTC.
/// `call_id`: Unique call identifier (UUIDv4).
/// `call_type`: "audio" or "video".
/// `recipient_pubkey_hex`: Hex-encoded public key of the callee.
///
/// Returns JSON-serialized gift-wrapped Event (kind 1059) to publish to relays.
Future<String> initiateCall({
  required String sdpOffer,
  required String callId,
  required String callType,
  required String recipientPubkeyHex,
}) => RustLib.instance.api.crateApiCallSignalingInitiateCall(
  sdpOffer: sdpOffer,
  callId: callId,
  callType: callType,
  recipientPubkeyHex: recipientPubkeyHex,
);

/// Accept a call by creating a gift-wrapped call answer event (kind 25051).
///
/// `sdp_answer`: SDP answer string from WebRTC.
/// `call_id`: Call identifier from the received offer.
/// `caller_pubkey_hex`: Hex-encoded public key of the caller.
///
/// Returns JSON-serialized gift-wrapped Event (kind 1059).
Future<String> acceptCall({
  required String sdpAnswer,
  required String callId,
  required String callerPubkeyHex,
}) => RustLib.instance.api.crateApiCallSignalingAcceptCall(
  sdpAnswer: sdpAnswer,
  callId: callId,
  callerPubkeyHex: callerPubkeyHex,
);

/// Reject an incoming call (kind 25053 with rejection reason).
///
/// `call_id`: Call identifier from the received offer.
/// `caller_pubkey_hex`: Hex-encoded public key of the caller.
/// `reason`: Optional rejection reason (e.g., "busy", "declined").
///
/// Returns JSON-serialized gift-wrapped Event (kind 1059).
Future<String> rejectCall({
  required String callId,
  required String callerPubkeyHex,
  String? reason,
}) => RustLib.instance.api.crateApiCallSignalingRejectCall(
  callId: callId,
  callerPubkeyHex: callerPubkeyHex,
  reason: reason,
);

/// Send an ICE candidate to the remote peer (kind 25052).
///
/// `candidate`: ICE candidate string.
/// `sdp_mid`: SDP media ID.
/// `sdp_m_line_index`: SDP media line index.
/// `call_id`: Call identifier.
/// `remote_pubkey_hex`: Hex-encoded public key of the remote peer.
///
/// Returns JSON-serialized gift-wrapped Event (kind 1059).
Future<String> sendIceCandidate({
  required String candidate,
  String? sdpMid,
  int? sdpMLineIndex,
  required String callId,
  required String remotePubkeyHex,
}) => RustLib.instance.api.crateApiCallSignalingSendIceCandidate(
  candidate: candidate,
  sdpMid: sdpMid,
  sdpMLineIndex: sdpMLineIndex,
  callId: callId,
  remotePubkeyHex: remotePubkeyHex,
);

/// End an active call (kind 25053).
///
/// `call_id`: Call identifier.
/// `remote_pubkey_hex`: Hex-encoded public key of the remote peer.
///
/// Returns JSON-serialized gift-wrapped Event (kind 1059).
Future<String> endCall({
  required String callId,
  required String remotePubkeyHex,
}) => RustLib.instance.api.crateApiCallSignalingEndCall(
  callId: callId,
  remotePubkeyHex: remotePubkeyHex,
);

/// Send a call state update (mute/camera toggle, kind 25054).
///
/// `call_id`: Call identifier.
/// `remote_pubkey_hex`: Hex-encoded public key of the remote peer.
/// `is_muted`: Current mute state, or None if unchanged.
/// `is_video_enabled`: Current video state, or None if unchanged.
///
/// Returns JSON-serialized gift-wrapped Event (kind 1059).
Future<String> sendCallStateUpdate({
  required String callId,
  required String remotePubkeyHex,
  bool? isMuted,
  bool? isVideoEnabled,
}) => RustLib.instance.api.crateApiCallSignalingSendCallStateUpdate(
  callId: callId,
  remotePubkeyHex: remotePubkeyHex,
  isMuted: isMuted,
  isVideoEnabled: isVideoEnabled,
);

/// Build a Nostr filter for subscribing to incoming call signaling events.
///
/// Subscribes to gift-wrapped events (kind 1059) addressed to the local user.
/// The client must unwrap received events and call `process_call_event()` on the inner event.
///
/// Returns JSON-serialized Filter.
Future<String> subscribeCallEvents() =>
    RustLib.instance.api.crateApiCallSignalingSubscribeCallEvents();

/// Process an unwrapped call signaling event and return structured data.
///
/// After receiving a gift-wrapped event (kind 1059) and unwrapping it via NIP-59,
/// pass the inner rumor event JSON here to parse it into a `CallSignalingEvent`.
///
/// `event_json`: JSON-serialized inner event (kind 25050-25054).
///
/// Returns `None` if the event is not a call signaling event.
Future<CallSignalingEvent?> processCallEvent({required String eventJson}) =>
    RustLib.instance.api.crateApiCallSignalingProcessCallEvent(
      eventJson: eventJson,
    );

/// Build a call signaling event for a group call (MLS-encrypted, not gift-wrapped).
///
/// For group calls, signaling goes through the Marmot group message channel.
/// This creates a rumor event that should be passed to `send_message()` for MLS encryption.
///
/// `kind_num`: Event kind (25050-25054).
/// `content`: JSON payload (SDP, ICE candidate, etc.).
/// `call_id`: Call identifier.
/// `call_type`: Optional call type ("audio" or "video").
///
/// Returns JSON-serialized unsigned rumor event to be encrypted via `send_message()`.
Future<String> buildGroupCallSignaling({
  required int kindNum,
  required String content,
  required String callId,
  String? callType,
}) => RustLib.instance.api.crateApiCallSignalingBuildGroupCallSignaling(
  kindNum: kindNum,
  content: content,
  callId: callId,
  callType: callType,
);

/// A parsed incoming call signaling event, flattened for FFI.
class CallSignalingEvent {
  /// Event kind (25050-25054).
  final int kind;

  /// Hex-encoded sender public key.
  final String senderPubkeyHex;

  /// Call ID from tags.
  final String callId;

  /// Call type from tags ("audio" or "video"), if present.
  final String? callType;

  /// Event content (JSON payload).
  final String content;

  /// Unix timestamp.
  final BigInt createdAt;

  const CallSignalingEvent({
    required this.kind,
    required this.senderPubkeyHex,
    required this.callId,
    this.callType,
    required this.content,
    required this.createdAt,
  });

  @override
  int get hashCode =>
      kind.hashCode ^
      senderPubkeyHex.hashCode ^
      callId.hashCode ^
      callType.hashCode ^
      content.hashCode ^
      createdAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CallSignalingEvent &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          senderPubkeyHex == other.senderPubkeyHex &&
          callId == other.callId &&
          callType == other.callType &&
          content == other.content &&
          createdAt == other.createdAt;
}
