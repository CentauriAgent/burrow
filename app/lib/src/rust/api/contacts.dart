// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `batch_check_key_packages`, `fetch_follow_list_inner`, `publish_follow_list`, `set_last_synced`, `sync_contacts_inner`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

/// Debug contacts sync: returns diagnostic info about each step.
Future<ContactsSyncDebug> debugSyncContacts() =>
    RustLib.instance.api.crateApiContactsDebugSyncContacts();

/// Return cached contacts (follows with key packages) from local SQLite.
/// Instant — no relay traffic. Returns empty list if DB is not yet initialized.
Future<List<ContactInfo>> getCachedContacts() =>
    RustLib.instance.api.crateApiContactsGetCachedContacts();

/// Full sync: fetch NIP-02 follow list, check key packages, resolve profiles,
/// update local SQLite, and return Marmot-capable contacts.
///
/// On any failure, returns whatever is currently cached rather than propagating
/// the error — this prevents the UI from showing an error screen.
Future<List<ContactInfo>> syncContacts() =>
    RustLib.instance.api.crateApiContactsSyncContacts();

/// Get the timestamp of the last contacts sync (epoch seconds), or None.
Future<PlatformInt64?> getLastContactsSync() =>
    RustLib.instance.api.crateApiContactsGetLastContactsSync();

/// Follow a contact by adding them to the NIP-02 follow list (kind 3).
/// Publishes the updated follow list to relays and updates local DB.
Future<void> followContact({required String pubkeyHex}) =>
    RustLib.instance.api.crateApiContactsFollowContact(pubkeyHex: pubkeyHex);

/// Unfollow a contact by removing them from the NIP-02 follow list (kind 3).
/// Publishes the updated follow list to relays and removes from local DB.
Future<void> unfollowContact({required String pubkeyHex}) =>
    RustLib.instance.api.crateApiContactsUnfollowContact(pubkeyHex: pubkeyHex);

/// A Marmot-capable contact (has published a key package).
class ContactInfo {
  final String pubkeyHex;
  final String? displayName;
  final String? picture;

  const ContactInfo({required this.pubkeyHex, this.displayName, this.picture});

  @override
  int get hashCode =>
      pubkeyHex.hashCode ^ displayName.hashCode ^ picture.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactInfo &&
          runtimeType == other.runtimeType &&
          pubkeyHex == other.pubkeyHex &&
          displayName == other.displayName &&
          picture == other.picture;
}

/// Diagnostic info for debugging contacts sync.
class ContactsSyncDebug {
  final int connectedRelays;
  final int followCount;
  final int keyPackageCount;
  final int dbFollowCount;
  final int dbKpCount;
  final String? error;

  const ContactsSyncDebug({
    required this.connectedRelays,
    required this.followCount,
    required this.keyPackageCount,
    required this.dbFollowCount,
    required this.dbKpCount,
    this.error,
  });

  @override
  int get hashCode =>
      connectedRelays.hashCode ^
      followCount.hashCode ^
      keyPackageCount.hashCode ^
      dbFollowCount.hashCode ^
      dbKpCount.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ContactsSyncDebug &&
          runtimeType == other.runtimeType &&
          connectedRelays == other.connectedRelays &&
          followCount == other.followCount &&
          keyPackageCount == other.keyPackageCount &&
          dbFollowCount == other.dbFollowCount &&
          dbKpCount == other.dbKpCount &&
          error == other.error;
}
