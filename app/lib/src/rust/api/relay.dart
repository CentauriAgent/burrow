// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Add a relay and connect to it.
Future<void> addRelay({required String url}) =>
    RustLib.instance.api.crateApiRelayAddRelay(url: url);

/// Remove a relay.
Future<void> removeRelay({required String url}) =>
    RustLib.instance.api.crateApiRelayRemoveRelay(url: url);

/// Connect to all added relays.
Future<void> connectRelays() =>
    RustLib.instance.api.crateApiRelayConnectRelays();

/// Disconnect from all relays.
Future<void> disconnectRelays() =>
    RustLib.instance.api.crateApiRelayDisconnectRelays();

/// List all configured relays and their connection status.
Future<List<RelayInfo>> listRelays() =>
    RustLib.instance.api.crateApiRelayListRelays();

/// Publish a signed event to connected relays.
/// Takes a JSON-serialized Nostr event string.
Future<String> publishEventJson({required String eventJson}) =>
    RustLib.instance.api.crateApiRelayPublishEventJson(eventJson: eventJson);

/// Verify that an event has been published to at least one relay.
/// Queries all connected relays for the event by ID and returns true if found.
Future<bool> verifyEventPublished({required String eventIdHex}) => RustLib
    .instance
    .api
    .crateApiRelayVerifyEventPublished(eventIdHex: eventIdHex);

/// Publish an event to a specific relay URL.
/// Used for retry logic when broadcast publish fails verification.
Future<String> publishEventJsonToRelay({
  required String eventJson,
  required String relayUrl,
}) => RustLib.instance.api.crateApiRelayPublishEventJsonToRelay(
  eventJson: eventJson,
  relayUrl: relayUrl,
);

/// Default relays for the Marmot/Burrow network.
List<String> defaultRelayUrls() =>
    RustLib.instance.api.crateApiRelayDefaultRelayUrls();

/// Status of a relay connection, flattened for FFI.
class RelayInfo {
  final String url;
  final bool connected;

  const RelayInfo({required this.url, required this.connected});

  @override
  int get hashCode => url.hashCode ^ connected.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RelayInfo &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          connected == other.connected;
}
