// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `now_secs`, `sessions`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`

/// Create a new call session.
///
/// `call_id`: Unique call identifier (UUIDv4).
/// `call_type`: "audio" or "video".
/// `direction`: "outgoing" or "incoming".
/// `local_pubkey_hex`: Local user's hex-encoded public key.
/// `remote_pubkey_hex`: Remote user's hex-encoded public key.
/// `group_id_hex`: Optional MLS group ID for group calls.
Future<CallSession> createSession({
  required String callId,
  required String callType,
  required String direction,
  required String localPubkeyHex,
  required String remotePubkeyHex,
  String? groupIdHex,
}) => RustLib.instance.api.crateApiCallSessionCreateSession(
  callId: callId,
  callType: callType,
  direction: direction,
  localPubkeyHex: localPubkeyHex,
  remotePubkeyHex: remotePubkeyHex,
  groupIdHex: groupIdHex,
);

/// Update the state of an existing call session.
///
/// `state`: One of "idle", "initiating", "ringing", "connecting", "active", "ending", "failed", "rejected".
Future<CallSession> updateSessionState({
  required String callId,
  required String state,
}) => RustLib.instance.api.crateApiCallSessionUpdateSessionState(
  callId: callId,
  state: state,
);

/// Get a call session by its ID.
Future<CallSession?> getSession({required String callId}) =>
    RustLib.instance.api.crateApiCallSessionGetSession(callId: callId);

/// Get all active call sessions (state is not Idle, Failed, Rejected, or Ending with ended_at set).
Future<List<CallSession>> getActiveCalls() =>
    RustLib.instance.api.crateApiCallSessionGetActiveCalls();

/// Remove a call session from the store (cleanup after call ends).
Future<void> removeSession({required String callId}) =>
    RustLib.instance.api.crateApiCallSessionRemoveSession(callId: callId);

/// Update local mute state for a call session.
Future<CallSession> setMuted({required String callId, required bool muted}) =>
    RustLib.instance.api.crateApiCallSessionSetMuted(
      callId: callId,
      muted: muted,
    );

/// Update local video enabled state for a call session.
Future<CallSession> setVideoEnabled({
  required String callId,
  required bool enabled,
}) => RustLib.instance.api.crateApiCallSessionSetVideoEnabled(
  callId: callId,
  enabled: enabled,
);

/// Derive a media encryption key from MLS exporter_secret for SFU frame encryption.
///
/// Uses HKDF-like derivation: SHA-256(exporter_secret || "burrow-media-v1" || call_id).
/// Returns 32-byte key as hex string.
///
/// `exporter_secret_hex`: Hex-encoded MLS exporter_secret from the group.
/// `call_id`: Unique call identifier used as context.
Future<String> deriveMediaKey({
  required String exporterSecretHex,
  required String callId,
}) => RustLib.instance.api.crateApiCallSessionDeriveMediaKey(
  exporterSecretHex: exporterSecretHex,
  callId: callId,
);

/// Direction of the call relative to local user.
enum CallDirection { outgoing, incoming }

/// A call session tracking all state for one call.
class CallSession {
  /// Unique identifier for this call (UUIDv4 string).
  final String callId;

  /// Current state of the call.
  final CallState state;

  /// Type of call (audio or video).
  final CallType callType;

  /// Direction (incoming or outgoing).
  final CallDirection direction;

  /// Hex-encoded public keys of all participants.
  final List<String> participants;

  /// Hex-encoded local user public key.
  final String localPubkeyHex;

  /// Hex-encoded remote user public key (1:1 calls).
  final String remotePubkeyHex;

  /// Optional hex-encoded MLS group ID (for group calls).
  final String? groupIdHex;

  /// Unix timestamp when session was created.
  final BigInt createdAt;

  /// Unix timestamp when call became active (media flowing).
  final BigInt? startedAt;

  /// Unix timestamp when call ended.
  final BigInt? endedAt;

  /// Whether local audio is muted.
  final bool isMuted;

  /// Whether local video is enabled.
  final bool isVideoEnabled;

  const CallSession({
    required this.callId,
    required this.state,
    required this.callType,
    required this.direction,
    required this.participants,
    required this.localPubkeyHex,
    required this.remotePubkeyHex,
    this.groupIdHex,
    required this.createdAt,
    this.startedAt,
    this.endedAt,
    required this.isMuted,
    required this.isVideoEnabled,
  });

  @override
  int get hashCode =>
      callId.hashCode ^
      state.hashCode ^
      callType.hashCode ^
      direction.hashCode ^
      participants.hashCode ^
      localPubkeyHex.hashCode ^
      remotePubkeyHex.hashCode ^
      groupIdHex.hashCode ^
      createdAt.hashCode ^
      startedAt.hashCode ^
      endedAt.hashCode ^
      isMuted.hashCode ^
      isVideoEnabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CallSession &&
          runtimeType == other.runtimeType &&
          callId == other.callId &&
          state == other.state &&
          callType == other.callType &&
          direction == other.direction &&
          participants == other.participants &&
          localPubkeyHex == other.localPubkeyHex &&
          remotePubkeyHex == other.remotePubkeyHex &&
          groupIdHex == other.groupIdHex &&
          createdAt == other.createdAt &&
          startedAt == other.startedAt &&
          endedAt == other.endedAt &&
          isMuted == other.isMuted &&
          isVideoEnabled == other.isVideoEnabled;
}

/// Call state machine states.
enum CallState {
  /// No active call.
  idle,

  /// Outgoing call initiated, waiting for remote answer.
  initiating,

  /// Incoming call ringing, waiting for local user to accept/reject.
  ringing,

  /// Signaling complete, ICE/DTLS negotiation in progress.
  connecting,

  /// Media flowing, call is active.
  active,

  /// Call is ending (hangup sent, waiting for cleanup).
  ending,

  /// Call failed (ICE failure, timeout, etc.).
  failed,

  /// Call was rejected by the remote party.
  rejected,
}

/// Type of call media.
enum CallType { audio, video }
